<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>æ–°éŠæˆ²ï¼</title>
    <style>
        /* --- é€šç”¨æ¨£å¼ (ä¾†è‡ª norma) --- */
        body { font-family: 'PingFang TC', 'Microsoft JhengHei', sans-serif; background: #f0f2f5; display: flex; flex-direction: column; align-items: center; padding: 20px; margin: 0; touch-action: manipulation; transition: background 0.5s; overflow-x: hidden; }
        .container { background: white; padding: 20px; border-radius: 12px; box-shadow: 0 4px 15px rgba(0,0,0,0.1); width: 100%; max-width: 500px; text-align: center; margin-bottom: 20px; position: relative; z-index: 10; transition: 0.3s; }
        .hidden { display: none !important; }
        
        /* æŒ‰éˆ•èˆ‡åˆ—è¡¨ (ä¾†è‡ª norma) */
        .menu-btn { width: 100%; padding: 15px; margin: 10px 0; font-size: 18px; cursor: pointer; border: none; border-radius: 8px; background: #007bff; color: white; transition: 0.2s; font-weight: bold; }
        .menu-btn:hover { background: #0056b3; transform: translateY(-2px); }
        .menu-btn:active { transform: translateY(0); }
        .btn-c4 { background: #2c3e50; } 
        .btn-purple { background: #6f42c1; }
        .btn-liar { background: #d35400; box-shadow: 0 4px 0 #a04000; }
        .btn-liar:hover { background: #e67e22; }
        
        .btn-sm { border: none; padding: 5px 12px; border-radius: 4px; cursor: pointer; font-size: 0.9em; margin-left: 5px; color: white; }
        .btn-green { background: #28a745; }
        .btn-red { background: #dc3545; }
        .btn-undo { background: #6c757d; color: white; border: none; padding: 10px 20px; border-radius: 8px; cursor: pointer; margin-top: 10px; }

        /* æˆ¿é–“åˆ—è¡¨é …ç›® (ä¾†è‡ª norma) */
        .room-item { border: 1px solid #ddd; padding: 12px; margin: 10px 0; display: flex; justify-content: space-between; align-items: center; border-radius: 8px; background: #fafafa; }
        .room-info { text-align: left; display: flex; flex-direction: column; }
        .room-name { font-weight: bold; font-size: 1.1em; }
        .lock-icon { font-size: 0.8em; margin-left: 5px; color: #d9534f; }
        .room-meta { font-size: 0.75em; color: #888; margin-top: 2px; }
        .status-badge { font-size: 0.7em; padding: 2px 6px; border-radius: 4px; margin-left: 5px; }
        .status-wait { background: #28a745; color: white; }
        .status-play { background: #dc3545; color: white; }

        /* çµ±è¨ˆèˆ‡è¼¸å…¥æ¡† (ä¾†è‡ª norma) */
        .stats-bar { background: #e9ecef; padding: 10px; border-radius: 8px; margin-bottom: 15px; font-size: 0.9em; color: #555; display: flex; justify-content: space-around; }
        .stat-item b { color: #007bff; font-size: 1.2em; }
        input { padding: 8px; text-align: center; border: 1px solid #ccc; border-radius: 4px; }
        .input-group { margin: 10px 0; text-align: left; display: flex; align-items: center; justify-content: space-between; }
        .settings-row { display: flex; gap: 10px; margin: 10px 0; }
        .settings-item { flex: 1; display: flex; flex-direction: column; }
        
        /* èŠå¤©å®¤ (ä¾†è‡ª norma) */
        #chat-area { margin-top: 15px; border-top: 1px solid #eee; padding-top: 10px; text-align: left; }
        #chat-msgs { height: 100px; overflow-y: auto; background: #f8f9fa; border-radius: 4px; padding: 5px; font-size: 0.85em; margin-bottom: 5px; border: 1px solid #ddd; }
        .chat-input-group { display: flex; gap: 5px; }
        .chat-input-group input { flex: 1; text-align: left; font-size: 0.9em; }
        .editable-name { color: #007bff; font-weight: bold; cursor: pointer; border-bottom: 1px dashed #007bff; }

        /* --- æ£‹ç›¤éŠæˆ²æ¨£å¼ (ä¾†è‡ª norma) --- */
        #gameArea { transition: 0.3s; }
        :root { --c4-cell-size: 40px; --p1-color: #ff4d4d; --p2-color: #ffd93d; }
        #c4-game-wrapper { display: flex; flex-direction: column; align-items: center; background-color: rgba(44, 62, 80, 0.9); padding: 15px; border-radius: 10px; overflow-x: auto; }
        .c4-board { display: grid; gap: 5px; padding: 10px; background: #3498db; border-radius: 10px; }
        .c4-cell { width: var(--c4-cell-size); height: var(--c4-cell-size); background-color: #1a252f; border-radius: 50%; }
        .piece { width: 100%; height: 100%; border-radius: 50%; animation: dropAnim 0.5s forwards; box-shadow: inset -3px -3px 5px rgba(0,0,0,0.3); }
        .p1 { background: var(--p1-color); } .p2 { background: var(--p2-color); }
        @keyframes dropAnim { from { transform: translateY(-200px); } to { transform: translateY(0); } }
        
        #ttt-board { display: grid; gap: 5px; margin: 10px auto; background: #ccc; padding: 5px; border-radius: 5px; }
        .ttt-cell { background: white; min-width: 40px; min-height: 40px; aspect-ratio: 1/1; display: flex; align-items: center; justify-content: center; font-size: 1.5rem; font-weight: bold; cursor: pointer; position: relative;}
        .about-to-die { opacity: 0.4; color: #d9534f; border: 2px dashed #d9534f; box-sizing: border-box; }

        /* ========================================= */
        /* --- ç§»æ¤ç‰ˆ é¨™å­æ¡ŒéŠ (Liar's Deck) æ¨£å¼ --- */
        /* ========================================= */
        #liar-wrapper {
            /* æœ¨è³ªé‚Šæ¡†èˆ‡è³ªæ„Ÿç‰Œæ¡Œ */
            background: radial-gradient(circle, #2e7d32 0%, #1b5e20 100%);
            border: 12px solid #5d4037;
            border-radius: 20px;
            box-shadow: inset 0 0 80px rgba(0,0,0,0.6), 0 10px 30px rgba(0,0,0,0.5);
            padding: 10px;
            color: #ecf0f1;
            position: relative;
            min-height: 550px;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            overflow: hidden;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
        }
        
        /* é ‚éƒ¨è³‡è¨Š */
        .liar-header {
            display: flex; justify-content: space-between; align-items: center;
            background: rgba(0,0,0,0.4); padding: 8px 15px; border-radius: 30px;
            border: 1px solid rgba(255,255,255,0.1); backdrop-filter: blur(5px);
        }
        .target-card-display {
            font-size: 1.4em; font-weight: 800; padding: 5px 20px;
            background: #f1c40f; color: #2c3e50; border-radius: 8px;
            border: 3px solid #fff; box-shadow: 0 4px 10px rgba(0,0,0,0.3);
            text-shadow: none;
        }

        /* ç‰Œæ¡Œä¸­å¤® */
        .liar-table-center {
            flex: 1; position: relative;
            display: flex; justify-content: center; align-items: center;
            perspective: 800px;
        }
        
        /* å¡ç‰Œè¨­è¨ˆ */
        .card {
            width: 55px; height: 80px;
            background: #fff; border-radius: 6px;
            box-shadow: 2px 2px 8px rgba(0,0,0,0.4);
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            font-weight: bold; font-size: 1.2em; position: relative;
            user-select: none; border: 1px solid #ccc;
            transition: transform 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            text-shadow: none;
        }
        .card.red { color: #c0392b; }
        .card.black { color: #2c3e50; }
        .card.joker { color: #8e44ad; border: 2px solid gold; }
        .card-back {
            background: repeating-linear-gradient(45deg, #922b21, #922b21 10px, #a93226 10px, #a93226 20px);
            border: 2px solid #ecf0f1;
        }
        .card-back::after { content: "âšœï¸"; color: rgba(255,255,255,0.3); font-size: 24px; }

        /* å°æ‰‹å€ */
        .opponents-row { display: flex; justify-content: space-around; width: 100%; margin-top: 10px; }
        .opponent {
            background: rgba(0,0,0,0.6); padding: 8px; border-radius: 10px;
            text-align: center; width: 80px; position: relative;
            transition: 0.3s; border: 2px solid transparent;
        }
        .opponent.active { border-color: #f1c40f; background: rgba(241, 196, 15, 0.2); transform: scale(1.05); }
        .opponent.dead { opacity: 0.6; filter: grayscale(100%); }
        .opponent.escaped { border-color: #2ecc71; opacity: 0.8; }
        
        /* æ§è†›é¡¯ç¤º */
        .cylinder-display {
            display: flex; justify-content: center; gap: 2px; margin-top: 5px;
        }
        .bullet-slot { width: 8px; height: 8px; border-radius: 50%; background: #555; border: 1px solid #888; }
        .bullet-slot.fired { background: #000; box-shadow: inset 0 0 2px rgba(255,255,255,0.5); }
        .bullet-slot.live { background: #e74c3c; box-shadow: 0 0 5px #c0392b; }

        /* æˆ‘çš„æ§æç‹€æ…‹é¡¯ç¤º */
        .my-gun-status {
            position: absolute;
            bottom: 140px;
            right: 10px;
            background: rgba(0, 0, 0, 0.7);
            padding: 8px;
            border-radius: 10px;
            color: white;
            text-align: center;
            border: 2px solid #7f8c8d;
            box-shadow: 0 0 10px rgba(0,0,0,0.5);
            z-index: 50;
        }

        /* æ‰‹ç‰Œå€ */
        .my-hand-area {
            height: 110px; display: flex; justify-content: center; align-items: center; gap: -10px;
            padding-bottom: 10px; z-index: 20;
        }
        .my-hand-area .card { margin: 0 4px; cursor: pointer; transform-origin: bottom center; }
        .my-hand-area .card:hover { transform: translateY(-15px) scale(1.1); z-index: 50; }
        .my-hand-area .card.selected { transform: translateY(-25px); border: 3px solid #f1c40f; box-shadow: 0 0 15px #f1c40f; }

        /* éŠæˆ²æŒ‰éˆ•å€ */
        .liar-controls { display: flex; gap: 15px; justify-content: center; margin-bottom: 10px; height: 50px; }
        .btn-game { 
            padding: 0 25px; border-radius: 25px; border: none; font-weight: 800; cursor: pointer; 
            font-size: 1.1em; color: white; box-shadow: 0 5px 0 rgba(0,0,0,0.3); 
            transition: 0.1s; text-transform: uppercase;
        }
        .btn-game:active { transform: translateY(4px); box-shadow: none; }
        .btn-play { background: linear-gradient(to bottom, #3498db, #2980b9); }
        .btn-liar-call { background: linear-gradient(to bottom, #e74c3c, #c0392b); font-size: 1.3em; letter-spacing: 1px; }
        .btn-liar-call:disabled { background: #7f8c8d; cursor: not-allowed; box-shadow: none; transform: translateY(4px); }

        /* --- å‹•ç•«ç‰¹æ•ˆå±¤ --- */
        /* æŠ“è¬Šç¿»ç‰Œå±¤ */
        .reveal-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85); z-index: 100;
            display: none; flex-direction: column; align-items: center; justify-content: center;
        }
        .reveal-stage { display: flex; gap: 15px; margin: 30px 0; perspective: 1000px; }
        .reveal-card-wrapper { width: 60px; height: 90px; position: relative; transform-style: preserve-3d; transition: transform 0.6s; }
        .reveal-card-wrapper.flipped { transform: rotateY(180deg); }
        .reveal-face, .reveal-back {
            position: absolute; width: 100%; height: 100%; backface-visibility: hidden;
            border-radius: 6px; display: flex; align-items: center; justify-content: center;
            font-size: 1.5em; font-weight: bold; text-shadow: none;
        }
        .reveal-back { background: repeating-linear-gradient(45deg, #922b21, #922b21 5px, #a93226 5px, #a93226 10px); border: 2px solid white; }
        .reveal-face { background: white; transform: rotateY(180deg); border: 4px solid transparent; }
        .reveal-face.correct { border-color: #2ecc71; box-shadow: 0 0 20px #2ecc71; }
        .reveal-face.wrong { border-color: #e74c3c; box-shadow: 0 0 20px #e74c3c; color: #e74c3c; }

        /* æ§æ“Šå‹•ç•«å±¤ */
        .gun-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 200; pointer-events: none; display: none;
            align-items: center; justify-content: center; flex-direction: column;
        }
        .gun-visual { font-size: 8em; animation: gunAim 1s ease-in-out infinite alternate; }
        .bang-visual { 
            position: absolute; font-size: 10em; color: yellow; font-weight: 900; 
            text-shadow: 0 0 20px red; opacity: 0; transform: scale(0);
        }
        .bang-animate { animation: bangPop 0.3s forwards; }

        @keyframes gunAim { from { transform: rotate(-5deg); } to { transform: rotate(5deg); } }
        @keyframes bangPop { 0% { opacity: 0; transform: scale(0.5); } 50% { opacity: 1; transform: scale(1.5); } 100% { opacity: 0; transform: scale(2); } }
        @keyframes shake { 0% { transform: translate(1px, 1px) rotate(0deg); } 10% { transform: translate(-1px, -2px) rotate(-1deg); } 20% { transform: translate(-3px, 0px) rotate(1deg); } 30% { transform: translate(3px, 2px) rotate(0deg); } 40% { transform: translate(1px, -1px) rotate(1deg); } 50% { transform: translate(-1px, 2px) rotate(-1deg); } 60% { transform: translate(-3px, 1px) rotate(0deg); } 70% { transform: translate(3px, 1px) rotate(-1deg); } 80% { transform: translate(-1px, -1px) rotate(1deg); } 90% { transform: translate(1px, 2px) rotate(0deg); } 100% { transform: translate(1px, -2px) rotate(-1deg); } }
        .shaking { animation: shake 0.5s; }

        /* --- å‹åˆ©ç‰¹æ•ˆ & å·¨å¤§æŒ‰éˆ• (ä¾†è‡ª norma) --- */
        #win-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.85); display: none; flex-direction: column; justify-content: center; align-items: center; z-index: 1000; color: white; }
        #win-message { font-size: 3em; margin-bottom: 10px; text-shadow: 0 0 10px rgba(255,255,255,0.5); text-align: center; padding: 0 20px;}
        .big-reset-btn { padding: 20px 40px; font-size: 24px; font-weight: bold; background: #28a745; color: white; border: none; border-radius: 50px; cursor: pointer; box-shadow: 0 0 20px rgba(40, 167, 69, 0.6); transition: 0.3s; margin-top: 20px;}
        .big-reset-btn:hover { transform: scale(1.1); }
        .waiting-text { animation: pulse 1.5s infinite; color: #f1c40f; }
        @keyframes pulse { 0% { opacity: 0.6; } 50% { opacity: 1; } 100% { opacity: 0.6; } }

    </style>
</head>
<body>

<div id="mainMenu" class="container">
    <h1>è‡ªå®šç¾©ç·šä¸ŠéŠæˆ²</h1>
    <div class="stats-bar">
        <div class="stat-item">å¤§å»³é–’ç½®: <b id="lobbyCount">0</b></div>
        <div class="stat-item">éŠæˆ²ä¸­: <b id="inGameCount">0</b></div>
    </div>

    <div id="allRoomsContainer">æœå°‹ä¸­...</div>
    <hr>
    <button class="menu-btn" onclick="showCreateRoom('ttt')">å‰µç«‹ åœˆåœˆå‰å‰â­•âŒ</button>
    <button class="menu-btn btn-c4" onclick="showCreateRoom('c4')">å‰µç«‹ å››é€£æ£‹ (é‡åŠ›è½ä¸‹)</button>
    <button class="menu-btn btn-liar" onclick="showCreateRoom('liar')">å‰µç«‹ é¨™å­æ¡ŒéŠ ğŸ”«ğŸƒ</button>
</div>

<div id="createRoomSection" class="container hidden">
    <h3 id="createTitle">å‰µç«‹æˆ¿é–“</h3>
    
    <div class="input-group"><label>æˆ¿é–“åç¨±:</label><input type="text" id="roomName" placeholder="æœªå‘½åæˆ¿é–“"></div>
    <div class="input-group"><label>è¨­å®šå¯†ç¢¼:</label><input type="password" id="roomPass" placeholder="å¯ç•™ç©º"></div>

    <hr style="margin: 15px 0; border: 0; border-top: 1px solid #eee;">
    
    <div id="normalSettings">
        <div style="text-align: left; font-weight: bold; margin-bottom: 5px;">éŠæˆ²è¦å‰‡è¨­å®š:</div>
        <div class="settings-row">
            <div class="settings-item">
                <label>é«˜ (Rows)</label>
                <input type="number" id="inputRows" min="3" max="15" value="3">
            </div>
            <div class="settings-item">
                <label>å¯¬ (Cols)</label>
                <input type="number" id="inputCols" min="3" max="15" value="3">
            </div>
            <div class="settings-item">
                <label>é€£ç·šæ•¸</label>
                <input type="number" id="inputWin" min="3" max="10" value="3">
            </div>
        </div>
        <div id="infinite-hint" style="font-size: 0.8em; color: #6f42c1; margin-bottom: 10px; display:none;">
            â€» ç„¡é™æ¨¡å¼ï¼šé›™æ–¹æœ€å¤š 3 é¡†æ£‹å­ï¼Œä¸‹ç¬¬ 4 é¡†æœ€æ—©çš„æ¶ˆå¤±ã€‚
        </div>
    </div>

    <div id="liarSettings" class="hidden" style="text-align: left; font-size: 0.9em; background:#fff3e0; padding:15px; border-radius:8px; margin:15px 0; border-left: 5px solid #d35400;">
        <h4 style="margin:0 0 5px 0; color:#d35400;">ğŸ”« é¨™å­é…’é¤¨è¦å‰‡ï¼š</h4>
        1. ç‰Œåº«å« A, Q, K (å„6å¼µ) + Joker (2å¼µ)ã€‚<br>
        2. ç³»çµ±æŒ‡å®šç›®æ¨™ (å¦‚ King)ï¼Œç©å®¶å¿…é ˆå‡ºç‰Œä¸¦å®£ç¨±ç¬¦åˆã€‚<br>
        3. è‹¥æ‡·ç–‘ä¸Šå®¶èªªè¬Šï¼Œå¯æŒ‰ä¸‹ <b style="color:#c0392b">LIAR!</b> æŠ“è¬Šã€‚<br>
        4. <b>æŠ“å°äº†</b>ï¼šèªªè¬Šè€…æ¥å—å·¦è¼ªåˆ¶è£ï¼›<b>æŠ“éŒ¯äº†</b>ï¼šæŠ“äººè€…æ¥å—åˆ¶è£ã€‚<br>
        5. <b>å‡ºå®Œç‰Œ</b>ï¼š3äººä»¥ä¸Šæ™‚ï¼Œå®‰å…¨ä¸Šå²¸ (è·³éå›åˆ)ï¼›è‹¥å‰©å…©äººæ™‚ä¸Šå®¶å‡ºå®Œç‰Œï¼Œä¸‹å®¶å¿…é ˆå¼·åˆ¶æŠ“è¬Šã€‚<br>
        6. 1/6 æ©Ÿç‡è§¸ç™¼å¯¦å½ˆï¼Œæ­»äº¡æ·˜æ±°ã€‚
    </div>

    <button id="btn-confirm" class="menu-btn" onclick="createRoom()">ç¢ºèªå‰µç«‹</button>
    <button id="btn-infinite" class="menu-btn btn-purple hidden" onclick="createInfiniteRoom()">å‰µç«‹ ç„¡é™åœˆåœˆå‰å‰ (åªç•™ä¸‰å­)</button>
    
    <button onclick="showSection('mainMenu')">è¿”å›</button>
</div>

<div id="gameArea" class="container hidden">
    <div style="display:flex; justify-content:space-between; align-items:center;">
        <h3 id="roomDisplayInfo" style="margin:5px 0;"></h3>
        <button class="btn-sm btn-red" onclick="leaveRoom()">é›¢é–‹</button>
    </div>
    <div id="gameMetaInfo" style="font-size: 0.85em; color: #666; margin-bottom: 5px;"></div>
    
    <div id="status" style="font-weight: bold; color: #d9534f; margin: 5px 0;">è¼‰å…¥ä¸­...</div>

    <div id="ttt-board" class="hidden"></div>
    <div id="c4-game-wrapper" class="hidden">
        <div class="color-pickers">
            <label class="color-label">P1è‰²: <input type="color" id="p1ColorPicker" value="#ff4d4d"></label>
            <label class="color-label">P2è‰²: <input type="color" id="p2ColorPicker" value="#ffd93d"></label>
        </div>
        <div id="c4-board" class="c4-board"></div>
    </div>

    <div id="liar-wrapper" class="hidden">
        <div class="liar-header">
            <span id="liar-status-text" style="font-size:0.9em;">ç­‰å¾…ç©å®¶...</span>
            <div id="liar-target-display" class="target-card-display hidden">K</div>
        </div>
        
        <div class="opponents-row" id="liar-opponents"></div>

        <div class="liar-table-center">
            <div id="liar-stack-area" style="position:relative; width:60px; height:90px; border: 2px dashed rgba(255,255,255,0.2); border-radius:6px;">
                </div>
            <div id="last-move-info" style="position:absolute; bottom:-30px; font-size:0.8em; color:#bdc3c7; background:rgba(0,0,0,0.5); padding:2px 8px; border-radius:10px;"></div>
        </div>
        
        <div id="my-gun-status" class="my-gun-status hidden"></div>

        <div class="my-hand-area" id="liar-my-hand"></div>
        
        <div class="liar-controls" id="liar-controls">
            <button id="btn-liar-start" class="btn-game btn-green hidden" onclick="startLiarGame()">é–‹å§‹è³­å±€</button>
            <button id="btn-liar-play" class="btn-game btn-play hidden" onclick="playLiarCards()">å‡ºç‰Œ</button>
            <button id="btn-liar-call" class="btn-game btn-liar-call hidden" onclick="callLiar()">LIAR!</button>
        </div>

        <div id="liar-reveal-overlay" class="reveal-overlay">
            <h2 style="color:white; text-shadow:0 0 10px black;">æª¢é©—ä¸­...</h2>
            <div class="reveal-stage" id="reveal-cards-container"></div>
            <div id="reveal-verdict" style="font-size:2em; font-weight:900; margin-top:20px; min-height:50px;"></div>
        </div>

        <div id="gun-anim-overlay" class="gun-overlay">
            <div class="gun-visual">ğŸ”«</div>
            <div class="bang-visual">BANG!</div>
            <div id="gun-result-text" style="color:white; font-size:1.5em; font-weight:bold; margin-top:20px; background:rgba(0,0,0,0.7); padding:10px;"></div>
        </div>
    </div>

    <button id="btn-undo" class="btn-undo" onclick="undoStep()">â¬… æ‚”æ£‹</button>

    <div id="chat-area">
        <div style="margin-bottom: 5px; font-size: 0.9em; color: #555;">
            æˆ‘æ˜¯: <span id="myNameDisplay" class="editable-name" onclick="editName()">ç©å®¶</span> âœ
        </div>
        <div id="chat-msgs"></div>
        <div class="chat-input-group">
            <input type="text" id="chatInput" placeholder="è¼¸å…¥è¨Šæ¯..." onkeypress="if(event.key==='Enter') sendMessage()">
            <button onclick="sendMessage()">å‚³é€</button>
        </div>
    </div>

    <div style="margin-top: 20px;">
        <button id="btn-restart-gen" onclick="resetGame()">é‡æ–°é–‹å§‹</button>
    </div>
</div>

<div id="win-overlay">
    <h1 id="win-message">å‹åˆ©ï¼</h1>
    <button class="big-reset-btn" onclick="resetGame()">ğŸ”„ é‡æ–°é–‹å§‹ ğŸ”„</button>
    <button style="margin-top:15px; background:none; border:1px solid white; color:white; padding:5px 10px; border-radius:20px;" onclick="closeWinOverlay()">æš«æ™‚é—œé–‰</button>
</div>

<script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-app.js";
    import { getDatabase, ref, set, onValue, push, update, remove, onDisconnect, serverTimestamp, get, runTransaction } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-database.js";

    const firebaseConfig = {
        apiKey: "AIzaSyC7PZLTTNf17cfp9gCHudWiWX8SYPSCdDI",
        authDomain: "onlineeasyraygame.firebaseapp.com",
        databaseURL: "https://onlineeasyraygame-default-rtdb.asia-southeast1.firebasedatabase.app",
        projectId: "onlineeasyraygame"
    };

    const app = initializeApp(firebaseConfig);
    const db = getDatabase(app);
    let currentRoomId = null, selectedGameType = 'ttt', roomDataCache = null;
    let currentUserKey = null;
    
    let selectedLiarCards = []; 
    let isAnimating = false;

    // --- ç©å®¶åç¨±åˆå§‹åŒ– (Sequence 1~99) ---
    let myName = localStorage.getItem('playerName');

    async function initializePlayerName() {
        if (!myName) {
            // å¦‚æœæœ¬åœ°æ²’æœ‰åå­—ï¼ŒåŸ·è¡Œ Firebase äº¤æ˜“ç²å– 1-99 ç·¨è™Ÿ
            const seqRef = ref(db, 'ongame_global/player_seq');
            try {
                const result = await runTransaction(seqRef, (currentSeq) => {
                    // è‹¥ä¸å­˜åœ¨æˆ–å·²é” 99ï¼Œé‡ç½®ç‚º 1ï¼›å¦å‰‡ +1
                    if (currentSeq === null || currentSeq >= 99) return 1;
                    return currentSeq + 1;
                });

                if (result.committed) {
                    const num = result.snapshot.val();
                    myName = `åŒ¿åç©å®¶${num}`;
                    localStorage.setItem('playerName', myName);
                } else {
                    myName = "åŒ¿åç©å®¶" + Math.floor(Math.random()*99+1); // Fallback
                }
            } catch (error) {
                console.error("Name transaction failed", error);
                myName = "åŒ¿åç©å®¶" + Math.floor(Math.random()*99+1);
            }
        }
        document.getElementById('myNameDisplay').innerText = myName;
    }

    // ç«‹å³åˆå§‹åŒ–åç¨±
    initializePlayerName();

    // --- å…¨ç«™ç·šä¸Šäººæ•¸çµ±è¨ˆ ---
    const onlineRef = push(ref(db, 'online'));
    onDisconnect(onlineRef).remove();
    set(onlineRef, true);

    let totalOnlineCount = 0;
    onValue(ref(db, 'online'), (snapshot) => {
        const val = snapshot.val();
        totalOnlineCount = val ? Object.keys(val).length : 0;
        updateStatsUI();
    });

    // --- åˆå§‹åŒ–ï¼šé¡¯ç¤ºæ‰€æœ‰æˆ¿é–“ ---
    let totalInGameCount = 0;
    onValue(ref(db, 'ongame_room'), (snapshot) => {
        const container = document.getElementById('allRoomsContainer');
        container.innerHTML = "";
        const rooms = snapshot.val();
        totalInGameCount = 0;

        if (!rooms) { 
            container.innerHTML = "<p>ç›®å‰æ²’æœ‰æˆ¿é–“ï¼Œä¾†é–‹ä¸€å€‹å§ï¼</p>"; 
            updateStatsUI();
            return; 
        }
        
        Object.entries(rooms).reverse().forEach(([id, r]) => {
            const userCount = r.users ? Object.keys(r.users).length : 0;
            totalInGameCount += userCount;

            let typeName = 'âŒä¸€èˆ¬åœˆå‰';
            if (r.type === 'c4') typeName = 'ğŸ”µé‡åŠ›å››é€£';
            if (r.type === 'ttt-infinite') typeName = 'â™¾ï¸ç„¡é™åœˆå‰';
            if (r.type === 'liar') typeName = 'ğŸ”«é¨™å­æ¡ŒéŠ';

            const hasPass = r.password && r.password !== "";
            const lockIcon = hasPass ? '<span class="lock-icon">ğŸ”’</span>' : '';
            const passwordArg = hasPass ? r.password : ""; 
            
            // ç‹€æ…‹åˆ¤æ–·
            let statusBadge = '<span class="status-badge status-wait">ç­‰å¾…ä¸­</span>';
            if (r.status === 'playing' || (r.turn > 0 && r.type !== 'liar')) {
                statusBadge = '<span class="status-badge status-play">éŠæˆ²ä¸­</span>';
            }

            let metaInfo = "";
            if (r.type === 'liar') {
                metaInfo = `äººæ•¸: ${userCount}`;
            } else {
                const rows = r.rows || 3;
                const cols = r.cols || 3;
                metaInfo = `å¤§å°: ${rows}x${cols} | äººæ•¸: ${userCount}`;
            }

            const div = document.createElement('div');
            div.className = 'room-item';
            div.innerHTML = `
                <div class="room-info">
                    <span class="room-name">${typeName} | ${r.name} ${lockIcon} ${statusBadge}</span>
                    <div class="room-meta">${metaInfo}</div>
                </div>
                <div>
                    <button class="btn-sm btn-green" onclick="attemptJoin('${id}', '${passwordArg}')">åŠ å…¥</button>
                    <button class="btn-sm btn-red" onclick="deleteRoom('${id}')">åˆªé™¤</button>
                </div>`;
            container.appendChild(div);
        });
        updateStatsUI();
    });

    function updateStatsUI() {
        const lobbyCount = Math.max(0, totalOnlineCount - totalInGameCount);
        document.getElementById('inGameCount').innerText = totalInGameCount;
        document.getElementById('lobbyCount').innerText = lobbyCount;
    }

    window.attemptJoin = (id, correctPass) => {
        if (correctPass && correctPass !== "undefined" && correctPass !== "") {
            const input = prompt("æ­¤æˆ¿é–“æœ‰å¯†ç¢¼ï¼Œè«‹è¼¸å…¥ï¼š");
            if (input !== correctPass) { alert("å¯†ç¢¼éŒ¯èª¤ï¼"); return; }
        }
        enterRoom(id);
    };

    // --- æˆ¿é–“ç®¡ç† ---
    window.showCreateRoom = (type) => {
        selectedGameType = type;
        const btnInfinite = document.getElementById('btn-infinite');
        const btnConfirm = document.getElementById('btn-confirm');
        const normalSettings = document.getElementById('normalSettings');
        const liarSettings = document.getElementById('liarSettings');
        
        let title = "å‰µç«‹æˆ¿é–“";
        document.getElementById('createTitle').innerText = title;

        // é‡ç½®é¡¯ç¤º
        btnInfinite.classList.add('hidden');
        normalSettings.classList.remove('hidden');
        liarSettings.classList.add('hidden');
        
        if (type === 'liar') {
            document.getElementById('createTitle').innerText = "å‰µç«‹ é¨™å­æ¡ŒéŠ (Liar's Deck)";
            normalSettings.classList.add('hidden');
            liarSettings.classList.remove('hidden');
            btnConfirm.innerText = "å‰µç«‹ è³­å±€";
            btnConfirm.onclick = createRoom;
        } else if (type === 'c4') {
            document.getElementById('createTitle').innerText = 'å‰µç«‹ å››é€£æ£‹';
            document.getElementById('inputRows').value = 6;
            document.getElementById('inputCols').value = 7;
            document.getElementById('inputWin').value = 4;
            btnConfirm.innerText = "ç¢ºèªå‰µç«‹";
            btnConfirm.onclick = createRoom;
        } else {
            document.getElementById('createTitle').innerText = 'å‰µç«‹ æ£‹ç›¤é€£ç·š';
            document.getElementById('inputRows').value = 3;
            document.getElementById('inputCols').value = 3;
            document.getElementById('inputWin').value = 3;
            btnInfinite.classList.remove('hidden');
            btnConfirm.innerText = "å‰µç«‹ ä¸€èˆ¬åœˆåœˆå‰å‰";
            btnConfirm.onclick = () => { selectedGameType = 'ttt'; createRoom(); };
        }
        showSection('createRoomSection');
    };

    window.createInfiniteRoom = () => { selectedGameType = 'ttt-infinite'; createRoom(); };

    window.createRoom = () => {
        const name = document.getElementById('roomName').value || "å¥½ç©æˆ¿é–“";
        const pass = document.getElementById('roomPass').value;
        const roomRef = push(ref(db, 'ongame_room'));
        
        let roomData = { name, password: pass, type: selectedGameType, users: {}, status: 'waiting', chat: {} };

        if (selectedGameType === 'liar') {
            roomData = { 
                ...roomData, 
                gameState: 'waiting', 
                deck: [], 
                stack: [], 
                hands: {}, 
                guns: {} 
            };
        } else {
            let rows = parseInt(document.getElementById('inputRows').value) || 3;
            let cols = parseInt(document.getElementById('inputCols').value) || 3;
            let win = parseInt(document.getElementById('inputWin').value) || 3;
            if(rows < 3) rows = 3; if(cols < 3) cols = 3; if(win < 3) win = 3;
            
            const initBoard = selectedGameType === 'c4' ? Array(rows * cols).fill(0) : Array(rows * cols).fill("");
            
            roomData = {
                ...roomData,
                board: initBoard, turn: 0, 
                rows: rows, cols: cols, winCondition: win,
                history: selectedGameType === 'ttt-infinite' ? [{board:initBoard, moves:[]}] : [initBoard],
                moves: selectedGameType === 'ttt-infinite' ? [] : null
            };
        }

        set(roomRef, roomData).then(() => enterRoom(roomRef.key));
    };

    window.enterRoom = (id) => {
        currentRoomId = id;
        showSection('gameArea');
        document.getElementById('myNameDisplay').innerText = myName;

        const userRef = push(ref(db, `ongame_room/${id}/users`));
        currentUserKey = userRef.key;
        onDisconnect(userRef).remove();
        
        set(userRef, { name: myName });

        // ç›£è½æˆ¿é–“è³‡æ–™
        onValue(ref(db, 'ongame_room/' + id), (snapshot) => {
            const data = snapshot.val();
            if (!data) { alert("æˆ¿é–“å·²è¢«åˆªé™¤æˆ–ä¸å­˜åœ¨"); leaveRoom(); return; }
            roomDataCache = data;
            
            if (isAnimating && data.type === 'liar') {
                if (data.gameState === 'playing' || data.gameState === 'waiting') {
                   // å…è¨±æ›´æ–°
                } else {
                   return; 
                }
            }
            
            if (data.type === 'liar') {
                renderLiarGame(data);
            } else {
                renderBoardGame(data);
            }
        });

        // ç›£è½èŠå¤©
        onValue(ref(db, `ongame_room/${id}/chat`), (snapshot) => {
            const chatDiv = document.getElementById('chat-msgs');
            chatDiv.innerHTML = "";
            const msgs = snapshot.val();
            if(msgs) {
                Object.values(msgs).forEach(m => {
                    const p = document.createElement('div');
                    p.innerHTML = `<b>${m.user}:</b> ${m.text}`;
                    chatDiv.appendChild(p);
                });
                chatDiv.scrollTop = chatDiv.scrollHeight;
            }
        });
    };
    
    // --- æ£‹ç›¤éŠæˆ²æ¸²æŸ“ (åœˆåœˆå‰å‰/å››é€£æ£‹) ---
    function renderBoardGame(data) {
        document.getElementById('liar-wrapper').classList.add('hidden');
        document.getElementById('btn-undo').classList.remove('hidden');
        document.getElementById('btn-restart-gen').classList.remove('hidden');
        document.getElementById('status').classList.remove('hidden');
        
        document.getElementById('roomDisplayInfo').innerText = data.name;
        const rows = data.rows || 3;
        const cols = data.cols || 3;
        const userList = data.users ? Object.values(data.users) : [];
        const p1Name = userList[0] ? userList[0].name : "P1";
        const p2Name = userList[1] ? userList[1].name : "P2";
        const currentPlayerName = (data.turn % 2 === 0) ? p1Name : p2Name;
        
        document.getElementById('gameMetaInfo').innerText = `${data.type === 'c4'?'å››é€£æ£‹':'åœˆå‰'} | ${rows}x${cols}`;

        if (data.type === 'c4') {
            document.getElementById('ttt-board').classList.add('hidden');
            document.getElementById('c4-game-wrapper').classList.remove('hidden');
            renderC4Board(data, rows, cols);
             document.getElementById('status').innerText = `è¼ªåˆ°: ${currentPlayerName} ${data.turn%2===0?'(P1)':'(P2)'}`;
             document.getElementById('status').style.color = (data.turn%2===0) ? (data.p1Color||'#ff4d4d') : (data.p2Color||'#ffd93d');
        } else {
            document.getElementById('c4-game-wrapper').classList.add('hidden');
            document.getElementById('ttt-board').classList.remove('hidden');
            renderTTTBoard(data, rows, cols);
            document.getElementById('status').innerText = `è¼ªåˆ°: ${currentPlayerName} (${data.turn%2===0?'X':'O'})`;
            document.getElementById('status').style.color = '#d9534f';
        }
        checkBoardWinner(data);
    }

    // --- ç§»æ¤ç‰ˆ é¨™å­æ¡ŒéŠ é‚è¼¯èˆ‡æ¸²æŸ“ ---

    function renderLiarGame(data) {
        // åˆ‡æ›é¡¯ç¤ºï¼Œéš±è—æ£‹ç›¤ç›¸é—œæŒ‰éˆ•
        document.getElementById('ttt-board').classList.add('hidden');
        document.getElementById('c4-game-wrapper').classList.add('hidden');
        document.getElementById('btn-undo').classList.add('hidden');
        document.getElementById('btn-restart-gen').classList.add('hidden');
        document.getElementById('status').classList.add('hidden');
        document.getElementById('liar-wrapper').classList.remove('hidden');
        
        document.getElementById('roomDisplayInfo').innerText = data.name;
        document.getElementById('gameMetaInfo').innerText = "Liar's Deck";

        const users = data.users || {};
        const playerKeys = data.playerOrder || Object.keys(users);
        const myIdx = playerKeys.indexOf(currentUserKey);
        
        // 1. è™•ç†ç‹€æ…‹é¡¯ç¤º
        const statusEl = document.getElementById('liar-status-text');
        const targetEl = document.getElementById('liar-target-display');
        const stackArea = document.getElementById('liar-stack-area');
        const myGunDiv = document.getElementById('my-gun-status');
        
        if (data.gameState === 'waiting') {
            statusEl.innerText = `æº–å‚™ä¸­ (${playerKeys.length}äºº)`;
            targetEl.classList.add('hidden');
            stackArea.innerHTML = "";
            myGunDiv.classList.add('hidden'); 
            document.getElementById('liar-reveal-overlay').style.display = 'none';
            document.getElementById('gun-anim-overlay').style.display = 'none';
            isAnimating = false;
            
            if (playerKeys[0] === currentUserKey && playerKeys.length >= 2) {
                document.getElementById('btn-liar-start').classList.remove('hidden');
            } else {
                document.getElementById('btn-liar-start').classList.add('hidden');
            }
        } 
        else if (data.gameState === 'playing') {
            document.getElementById('btn-liar-start').classList.add('hidden');
            document.getElementById('liar-reveal-overlay').style.display = 'none';
            document.getElementById('gun-anim-overlay').style.display = 'none';
            targetEl.classList.remove('hidden');
            targetEl.innerText = `ç›®æ¨™: ${data.targetRank}`;
            myGunDiv.classList.remove('hidden');
            
            const curPlayerKey = playerKeys[data.turnIndex];
            const curPlayer = users[curPlayerKey];
            const isMyTurn = (curPlayerKey === currentUserKey);
            
            // --- ç‰¹åˆ¥è¦å‰‡æª¢æŸ¥ï¼š2äººå°æ±ºä¸”å°æ‰‹ç„¡ç‰Œ ---
            // è¦å‰‡æ›´æ–°ï¼šå¦‚æœåªå‰©2äººå­˜æ´»ï¼Œä¸”ä¸Šå®¶å‡ºå®Œç‰Œ (é€™æ™‚ currentHand æ˜¯ç©ºçš„)
            // ä¸‹å®¶å¿…é ˆå¼·åˆ¶æŠ“è¬Šã€‚
            const aliveKeys = playerKeys.filter(k => !data.guns[k]?.isDead);
            const lastMove = data.stack && data.stack.length > 0 ? data.stack[data.stack.length - 1] : null;
            let forceCall = false;

            if (aliveKeys.length === 2 && lastMove) {
                // å¦‚æœä¸Šä¸€ä½å‡ºç‰Œè€…ç¾åœ¨æ‰‹ç‰Œæ˜¯ç©ºçš„ (ä»£è¡¨ä»–å‡ºå®Œäº†)
                const prevOwnerHand = data.hands[lastMove.owner];
                if (prevOwnerHand && prevOwnerHand.length === 0) {
                    forceCall = true;
                }
            }
            
            if (forceCall) {
                statusEl.innerHTML = isMyTurn ? 
                    `<b style="color:#e74c3c">âš ï¸ å°æ–¹å·²å‡ºå®Œç‰Œï¼å¼·åˆ¶æŠ“è¬Šï¼</b>` : 
                    `å°æ‰‹å‡ºå®Œç‰Œï¼Œæ­£åœ¨è¢«å¼·åˆ¶æª¢é©—...`;
            } else {
                statusEl.innerHTML = isMyTurn ? 
                    `<b style="color:#f1c40f">ğŸ”´ è¼ªåˆ°ä½ äº†ï¼è«‹å‡ºç‰Œ</b>` : 
                    `ç­‰å¾… ${curPlayer?.name || 'å°æ‰‹'} å‡ºç‰Œ...`;
            }

            // æŒ‰éˆ•é‚è¼¯
            const btnCall = document.getElementById('btn-liar-call');
            const btnPlay = document.getElementById('btn-liar-play');
            
            if (isMyTurn) {
                if (forceCall) {
                    // å¼·åˆ¶æŠ“è¬Šæ¨¡å¼
                    btnPlay.classList.add('hidden');
                    btnCall.classList.remove('hidden');
                    btnCall.innerText = "âš ï¸ å°æ–¹ç„¡ç‰Œï¼å¼·åˆ¶æŠ“è¬Š âš ï¸";
                    btnCall.style.background = "linear-gradient(to bottom, #c0392b, #96281b)";
                } else {
                    // æ­£å¸¸æ¨¡å¼
                    btnPlay.classList.remove('hidden');
                    btnCall.classList.toggle('hidden', !(data.stack && data.stack.length > 0));
                    btnCall.innerText = "LIAR!";
                    btnCall.style.background = ""; // é‡ç½®æ¨£å¼
                }
            } else {
                btnPlay.classList.add('hidden');
                btnCall.classList.add('hidden');
            }

            // æ¸²æŸ“å †ç–Š
            stackArea.innerHTML = "";
            if (data.stack) {
                data.stack.forEach((move, i) => {
                    if (i < data.stack.length - 10) return; // åªæ¸²æŸ“æœ€å¾Œå¹¾å¼µ
                    const c = document.createElement('div');
                    c.className = 'card card-back';
                    c.style.position = 'absolute';
                    c.style.width = '40px'; c.style.height = '60px';
                    c.style.transform = `rotate(${Math.sin(i*99)*20}deg) translate(${Math.cos(i)*5}px, ${Math.sin(i)*5}px)`;
                    stackArea.appendChild(c);
                });
                if (data.lastMove) {
                    document.getElementById('last-move-info').innerText = `${data.lastMove.name} å‡ºäº† ${data.lastMove.count} å¼µ`;
                }
            }
        }
        else if (data.gameState === 'challenge' && !isAnimating) {
             triggerChallengeAnimation(data);
        }

        // 2. æ¸²æŸ“å°æ‰‹
        const oppRow = document.getElementById('liar-opponents');
        oppRow.innerHTML = "";
        playerKeys.forEach(k => {
            if (k === currentUserKey) return;
            const u = users[k];
            if (!u) return;
            const handSize = data.hands && data.hands[k] ? data.hands[k].length : 0;
            const gun = data.guns ? data.guns[k] : {chamber:0, isDead:false};
            
            let statusClass = "";
            if (k === playerKeys[data.turnIndex]) statusClass = "active";
            if (gun.isDead) statusClass = "dead";
            if (!gun.isDead && handSize === 0 && data.gameState === 'playing') statusClass = "escaped"; // ä¸Šå²¸

            const div = document.createElement('div');
            div.className = `opponent ${statusClass}`;
            
            // æ§æåœ–ç¤º
            let bulletsHTML = "";
            for(let i=0; i<6; i++) {
                let bClass = (i < gun.chamber) ? "fired" : "live";
                bulletsHTML += `<div class="bullet-slot ${bClass}"></div>`;
            }

            div.innerHTML = `
                <div style="font-size:0.8em; overflow:hidden; text-overflow:ellipsis; white-space:nowrap;">${u.name}</div>
                <div style="font-size:1.5em; margin:5px 0;">ğŸƒ ${handSize}</div>
                <div class="cylinder-display">${bulletsHTML}</div>
                ${gun.isDead ? '<span style="position:absolute; top:30%; left:25%; font-size:2em;">ğŸ’€</span>' : ''}
                ${statusClass==='escaped' ? '<span style="position:absolute; top:30%; left:20%; font-size:1.5em; color:#2ecc71; font-weight:bold;">SAFE</span>' : ''}
            `;
            oppRow.appendChild(div);
        });
        
        // 2.5 æ¸²æŸ“è‡ªå·±çš„æ§æç‹€æ…‹
        const myGunInfo = data.guns ? data.guns[currentUserKey] : {chamber:0, isDead:false};
        if (myGunDiv && data.gameState !== 'waiting') {
            let bulletsHTML = "";
            for(let i=0; i<6; i++) {
                let bClass = (i < myGunInfo.chamber) ? "fired" : "live";
                bulletsHTML += `<div class="bullet-slot ${bClass}"></div>`;
            }
            myGunDiv.innerHTML = `
                <div style="font-size:0.8em; margin-bottom:5px;">æˆ‘çš„å·¦è¼ª</div>
                <div class="cylinder-display">${bulletsHTML}</div>
                <div style="font-size:0.7em; margin-top:3px; color:#bdc3c7;">
                    ${myGunInfo.isDead ? 'å·²æ­»äº¡' : `å‰©é¤˜æ©Ÿç‡: 1/${6 - myGunInfo.chamber}`}
                </div>
            `;
            if (myGunInfo.isDead) myGunDiv.style.borderColor = "red";
            else myGunDiv.style.borderColor = "#7f8c8d";
        }


        // 3. æ¸²æŸ“è‡ªå·±æ‰‹ç‰Œ
        const myHandDiv = document.getElementById('liar-my-hand');
        const myCards = (data.hands && data.hands[currentUserKey]) || [];
        myHandDiv.innerHTML = "";
        
        if (selectedLiarCards.some(idx => idx >= myCards.length)) selectedLiarCards = [];

        myCards.forEach((c, i) => {
            const div = document.createElement('div');
            div.className = `card ${['â™¥','â™¦'].includes(c.suit)?'red':'black'} ${c.rank==='Joker'?'joker':''}`;
            if (selectedLiarCards.includes(i)) div.classList.add('selected');
            
            if (c.rank === 'Joker') div.innerHTML = 'ğŸ¤¡<br>Joker';
            else div.innerHTML = `${c.suit}<br>${c.rank}`;
            
            div.onclick = () => {
                if (data.gameState !== 'playing') return;
                // å¼·åˆ¶æŠ“è¬Šæ™‚ä¸èƒ½é¸ç‰Œ
                if (statusEl.innerHTML.includes("å¼·åˆ¶æŠ“è¬Š")) return; 
                
                const idx = selectedLiarCards.indexOf(i);
                if (idx >= 0) {
                    selectedLiarCards.splice(idx, 1);
                    div.classList.remove('selected');
                } else {
                    if (selectedLiarCards.length >= 3) return alert("æœ€å¤šå‡º3å¼µ");
                    selectedLiarCards.push(i);
                    div.classList.add('selected');
                }
            };
            myHandDiv.appendChild(div);
        });
        
        // è‡ªå·±çš„æ§èˆ‡æ­»äº¡ç‹€æ…‹
        const myGun = data.guns && data.guns[currentUserKey];
        if (myGun && myGun.isDead) {
             statusEl.innerHTML = "<b style='color:red'>ğŸ’€ ä½ å·²æ­»äº¡</b>";
             document.getElementById('liar-controls').classList.add('hidden');
        }
    }

    // --- å‹•ç•«é‚è¼¯ (ç§»æ¤è‡ª test) ---
    async function triggerChallengeAnimation(data) {
        if (isAnimating) return;
        isAnimating = true;

        const res = data.challengeResult;
        const overlay = document.getElementById('liar-reveal-overlay');
        const container = document.getElementById('reveal-cards-container');
        const verdict = document.getElementById('reveal-verdict');
        
        overlay.style.display = 'flex';
        container.innerHTML = "";
        verdict.innerHTML = "";
        
        // 1. ç”¢ç”Ÿç‰ŒèƒŒ
        res.cards.forEach((c, i) => {
            const wrapper = document.createElement('div');
            wrapper.className = 'reveal-card-wrapper';
            wrapper.innerHTML = `
                <div class="reveal-back"></div>
                <div class="reveal-face ${['â™¥','â™¦'].includes(c.suit)?'red':'black'}">
                    ${c.rank==='Joker'?'ğŸ¤¡': c.suit + c.rank}
                </div>
            `;
            container.appendChild(wrapper);
        });

        // 2. ä¾åºç¿»ç‰Œ
        await new Promise(r => setTimeout(r, 500));
        const cards = container.children;
        
        for (let i = 0; i < cards.length; i++) {
            cards[i].classList.add('flipped');
            const cData = res.cards[i];
            const isMatch = (cData.rank === data.targetRank || cData.rank === 'Joker');
            
            await new Promise(r => setTimeout(r, 600));
            const face = cards[i].querySelector('.reveal-face');
            if (isMatch) {
                face.classList.add('correct');
            } else {
                face.classList.add('wrong');
            }
            await new Promise(r => setTimeout(r, 400));
        }

        // 3. é¡¯ç¤ºçµæœæ–‡å­—
        verdict.innerHTML = res.isLiar 
            ? `<span style="color:#e74c3c">æŠ“åˆ°äº†ï¼èªªè¬Šï¼</span><br><span style="font-size:0.5em">è¼¸å®¶: ${res.loserName}</span>` 
            : `<span style="color:#2ecc71">èª å¯¦ï¼æŠ“éŒ¯äº†ï¼</span><br><span style="font-size:0.5em">è¼¸å®¶: ${res.loserName}</span>`;
        
        await new Promise(r => setTimeout(r, 1500));

        // 4. é€²å…¥é–‹æ§ç’°ç¯€
        overlay.style.display = 'none';
        await triggerGunAnimation(res.loser, res.loserName);
    }

    async function triggerGunAnimation(loserId, loserName) {
        const overlay = document.getElementById('gun-anim-overlay');
        const txt = document.getElementById('gun-result-text');
        const bang = overlay.querySelector('.bang-visual');
        
        overlay.style.display = 'flex';
        txt.innerText = `${loserName} æ¥å—åˆ¶è£...`;
        bang.style.opacity = 0;
        bang.classList.remove('bang-animate');

        // ç„æº–å‹•ç•«
        await new Promise(r => setTimeout(r, 1500)); 
        
        // æ¨¡æ“¬é–‹æ§
        overlay.classList.add('shaking');
        bang.classList.add('bang-animate');
        
        // æª¢æŸ¥æ­¤äººæ˜¯å¦çœŸçš„æ­»äº†
        const roomSnapshot = await get(ref(db, `ongame_room/${currentRoomId}`));
        const rData = roomSnapshot.val();
        const playerGun = rData.guns[loserId];
        
        // å»¶é²é¡¯ç¤ºçµæœ
        await new Promise(r => setTimeout(r, 500));
        overlay.classList.remove('shaking');
        
        if (playerGun.isDead) {
            txt.innerHTML = `<span style="color:red; font-size:1.5em;">ğŸ’€ æ­»äº¡ ğŸ’€</span>`;
        } else {
            txt.innerHTML = `<span style="color:#2ecc71">æ­å–œå€–å­˜ğŸ˜(ç©ºåŒ…å½ˆ)</span><br>å‰©é¤˜: ${6 - playerGun.chamber}ç™¼`;
        }

        await new Promise(r => setTimeout(r, 2000));
        overlay.style.display = 'none';
        
        // ç”±æˆ¿ä¸»æˆ–è§¸ç™¼è€…æ¨é€²éŠæˆ²
        const players = rData.playerOrder;
        if (players[0] === currentUserKey) {
            nextLiarRound(rData);
        }
        
        isAnimating = false; 
    }

    // --- é¨™å­æ¡ŒéŠ æ“ä½œå‡½å¼ ---
    window.startLiarGame = () => {
        const ranks = ['A', 'Q', 'K'];
        const suits = ['â™ ', 'â™¥', 'â™¦', 'â™£', 'â™ ', 'â™¥'];
        let deck = [];
        ranks.forEach(r => suits.forEach(s => deck.push({suit:s, rank:r})));
        deck.push({suit:'', rank:'Joker'}, {suit:'', rank:'Joker'});
        deck.sort(() => Math.random() - 0.5);

        const players = Object.keys(roomDataCache.users);
        const hands = {};
        players.forEach(p => hands[p] = deck.splice(0, 5));
        
        // é‡ç½®æ§æ
        const guns = {};
        players.forEach(p => guns[p] = { chamber: 0, bulletPos: Math.floor(Math.random()*6), isDead: false });

        update(ref(db, `ongame_room/${currentRoomId}`), {
            gameState: 'playing', deck, hands, guns, stack: [],
            playerOrder: players, turnIndex: 0, targetRank: ranks[Math.floor(Math.random()*3)],
            challengeResult: null, status: 'playing'
        });
    };

    window.playLiarCards = () => {
        if (!selectedLiarCards.length) return alert("è«‹é¸ç‰Œ");
        
        const myHand = roomDataCache.hands[currentUserKey];
        const played = selectedLiarCards.map(i => myHand[i]);
        const newHand = myHand.filter((_, i) => !selectedLiarCards.includes(i));
        
        const stack = roomDataCache.stack || [];
        stack.push({ cards: played, owner: currentUserKey, name: myName, count: played.length });
        
        const players = roomDataCache.playerOrder;
        
        // --- æ›´æ–°æ¼”ç®—æ³•ï¼šè™•ç†å®‰å…¨è·³éæ©Ÿåˆ¶ (Skip Safe) ---
        let nextIdx = roomDataCache.turnIndex;
        let found = false;
        let loopCount = 0;
        
        // è¨ˆç®—å­˜æ´»äººæ•¸
        const aliveCount = players.filter(p => !roomDataCache.guns[p].isDead).length;

        while (loopCount < players.length) {
            nextIdx = (nextIdx + 1) % players.length;
            const pId = players[nextIdx];
            const gun = roomDataCache.guns[pId];
            const pHand = roomDataCache.hands[pId] || []; // ç©å®¶æ‰‹ç‰Œ
            
            // 1. æ­»äººè·³é
            if (gun.isDead) {
                loopCount++;
                continue;
            }

            // 2. å®‰å…¨ä¸Šå²¸é‚è¼¯
            // è¦å‰‡ï¼šå¦‚æœå­˜æ´»äººæ•¸å¤§æ–¼ 2ï¼Œä¸”è©²ç©å®¶æ²’ç‰Œäº†ï¼Œè¦–ç‚ºå®‰å…¨ (SAFE)ï¼Œè·³éä»–ã€‚
            // è¦å‰‡ï¼šå¦‚æœå­˜æ´»äººæ•¸ç­‰æ–¼ 2ï¼Œä¸”è©²ç©å®¶æ²’ç‰Œäº†ï¼Œä¸è·³é (å› ç‚ºéœ€è¦å¼·åˆ¶å°æ–¹æŠ“è¬Š)ã€‚
            if (aliveCount > 2 && pHand.length === 0) {
                 loopCount++;
                 continue; 
            }
            
            // æ‰¾åˆ°äº†æ´»è‘—ä¸”ç¬¦åˆè¦å‰‡çš„ç©å®¶
            found = true;
            break;
        }

        if (!found) {
            alert("éŠæˆ²ç•°å¸¸ï¼šæ‰¾ä¸åˆ°ä¸‹ä¸€ä½å­˜æ´»ç©å®¶");
            return;
        }

        update(ref(db, `ongame_room/${currentRoomId}`), {
            [`hands/${currentUserKey}`]: newHand,
            stack: stack,
            turnIndex: nextIdx,
            lastMove: { name: myName, count: played.length }
        });
        selectedLiarCards = [];
    };

    window.callLiar = async () => {
        const roomSnapshot = await get(ref(db, `ongame_room/${currentRoomId}`));
        const rData = roomSnapshot.val();

        if (!rData || !rData.stack || rData.stack.length === 0) return;

        const stack = rData.stack;
        const lastEntry = stack[stack.length - 1];
        const target = rData.targetRank;
        
        // è¦å‰‡ï¼šåªè¦æœ‰ä»»ä½•ä¸€å¼µä¸æ˜¯ç›®æ¨™ä¸”ä¸æ˜¯Jokerï¼Œå°±æ˜¯èªªè¬Š
        let isLiar = lastEntry.cards.some(c => c.rank !== target && c.rank !== 'Joker');
        
        // æŠ“å°äº† -> å‡ºç‰Œè€…(owner)è¼¸
        // æŠ“éŒ¯äº† -> æŠ“äººè€…(currentUserKey)è¼¸
        const loserId = isLiar ? lastEntry.owner : currentUserKey;
        const loserName = rData.users[loserId].name;

        // è™•ç†é–‹æ§é‚è¼¯
        const gun = rData.guns[loserId];
        const died = (gun.chamber === gun.bulletPos);
        const updates = {};
        
        updates[`guns/${loserId}/chamber`] = gun.chamber + 1;
        if(died) updates[`guns/${loserId}/isDead`] = true;
        
        updates['challengeResult'] = {
            cards: lastEntry.cards, isLiar, loser: loserId, loserName
        };
        updates['gameState'] = 'challenge';
        
        update(ref(db, `ongame_room/${currentRoomId}`), updates);
    };

    function nextLiarRound(rData) {
        const players = rData.playerOrder;
        const alive = players.filter(p => !rData.guns[p].isDead);
        
        // å‰©ä¸‹ä¸€äººç²å‹
        if (alive.length <= 1) {
            const winnerName = alive.length > 0 ? rData.users[alive[0]].name : "ç„¡äºº";
            document.getElementById('win-message').innerHTML = `ğŸ† æœ€å¾Œç”Ÿé‚„è€…<br>${winnerName}`;
            document.getElementById('win-overlay').style.display = 'flex';
            return;
        }

        // ç™¼ç‰Œåªç™¼çµ¦æ´»äºº
        const ranks = ['A', 'Q', 'K'];
        const suits = ['â™ ', 'â™¥', 'â™¦', 'â™£', 'â™ ', 'â™¥'];
        let deck = [];
        ranks.forEach(r => suits.forEach(s => deck.push({suit:s, rank:r})));
        deck.push({suit:'', rank:'Joker'}, {suit:'', rank:'Joker'});
        deck.sort(() => Math.random() - 0.5);
        
        const hands = {};
        alive.forEach(p => hands[p] = deck.splice(0, 5));

        // éš¨æ©Ÿé¸ä¸€å€‹æ´»äººé–‹å§‹
        const starter = alive[Math.floor(Math.random()*alive.length)];
        const startIdx = players.indexOf(starter);

        update(ref(db, `ongame_room/${currentRoomId}`), {
            gameState: 'playing', hands, deck, stack: [],
            targetRank: ranks[Math.floor(Math.random()*3)],
            turnIndex: startIdx, challengeResult: null
        });
    }
    
    // --- è¼”åŠ©å‡½å¼ ---
    function renderC4Board(data, rows, cols) {
        const boardDiv = document.getElementById('c4-board');
        boardDiv.style.gridTemplateColumns = `repeat(${cols}, var(--c4-cell-size))`;
        const size = cols > 10 ? '30px' : (cols > 7 ? '35px' : '45px');
        document.documentElement.style.setProperty('--c4-cell-size', size);
        boardDiv.innerHTML = "";
        data.board.forEach((val, i) => {
            const cell = document.createElement('div');
            cell.className = 'c4-cell';
            if(val > 0) cell.innerHTML = `<div class="piece p${val}"></div>`;
            cell.onclick = () => dropC4(i % cols, rows, cols);
            boardDiv.appendChild(cell);
        });
    }

    function renderTTTBoard(data, rows, cols) {
        const boardDiv = document.getElementById('ttt-board');
        boardDiv.style.gridTemplateColumns = `repeat(${cols}, 1fr)`;
        boardDiv.innerHTML = "";
        let indexToFade = -1;
        if (data.type === 'ttt-infinite' && data.moves) {
            const moves = data.moves;
            const currentSymbol = (data.turn % 2 === 0) ? 'X' : 'O';
            const myMoves = moves.filter(m => m.player === currentSymbol);
            if (myMoves.length >= 3) indexToFade = myMoves[0].index;
        }
        data.board.forEach((val, i) => {
            const cell = document.createElement('div');
            cell.className = 'ttt-cell';
            if (i === indexToFade) cell.classList.add('about-to-die');
            cell.innerText = val;
            cell.onclick = () => clickTTT(i);
            boardDiv.appendChild(cell);
        });
    }

    window.dropC4 = (col, rows, cols) => {
        if(roomDataCache.type !== 'c4') return;
        const board = [...roomDataCache.board];
        for (let r = rows - 1; r >= 0; r--) {
            const index = r * cols + col;
            if (board[index] === 0) {
                board[index] = (roomDataCache.turn % 2) + 1;
                updateMove(board);
                break;
            }
        }
    }
    
    window.clickTTT = (i) => {
        if(roomDataCache.type === 'c4' || roomDataCache.type === 'liar') return;
        if (roomDataCache.board[i] !== "") return;
        const isInfinite = (roomDataCache.type === 'ttt-infinite');
        const board = [...roomDataCache.board];
        const currentPlayer = roomDataCache.turn % 2 === 0 ? "X" : "O";
        let newMoves = isInfinite ? (roomDataCache.moves ? [...roomDataCache.moves] : []) : null;
        
        board[i] = currentPlayer;
        if (isInfinite) {
            newMoves.push({ index: i, player: currentPlayer });
            const myMoves = newMoves.filter(m => m.player === currentPlayer);
            if (myMoves.length > 3) {
                const moveToRemove = myMoves[0];
                board[moveToRemove.index] = "";
                const realIndex = newMoves.indexOf(moveToRemove);
                if (realIndex > -1) newMoves.splice(realIndex, 1);
            }
            updateMove(board, newMoves);
        } else {
            updateMove(board);
        }
    }

    function updateMove(newBoard, newMoves = null) {
        const history = roomDataCache.history || [];
        const isInfinite = (roomDataCache.type === 'ttt-infinite');
        if (isInfinite) {
            history.push({ board: newBoard, moves: newMoves });
            update(ref(db, `ongame_room/${currentRoomId}`), { board: newBoard, moves: newMoves, turn: roomDataCache.turn + 1, history: history });
        } else {
            history.push(newBoard);
            update(ref(db, `ongame_room/${currentRoomId}`), { board: newBoard, turn: roomDataCache.turn + 1, history: history });
        }
    }

    window.undoStep = () => {
        const history = roomDataCache.history || [];
        if (history.length <= 1) return alert("ä¸èƒ½å†é€€äº†ï¼");
        history.pop();
        const lastState = history[history.length - 1];
        const isInfinite = (roomDataCache.type === 'ttt-infinite');
        if (isInfinite) {
            update(ref(db, `ongame_room/${currentRoomId}`), { board: lastState.board||lastState, moves: lastState.moves||[], turn: roomDataCache.turn - 1, history: history });
        } else {
            update(ref(db, `ongame_room/${currentRoomId}`), { board: lastState, turn: roomDataCache.turn - 1, history: history });
        }
    };

    window.sendMessage = () => {
        const input = document.getElementById('chatInput');
        if (!input.value.trim()) return;
        push(ref(db, `ongame_room/${currentRoomId}/chat`), { user: myName, text: input.value, time: serverTimestamp() });
        input.value = "";
    };

    window.editName = () => {
        const newName = prompt("è«‹è¼¸å…¥æ‚¨çš„æ–°æš±ç¨±:", myName);
        if (newName && newName.trim() !== "") {
            myName = newName.trim();
            localStorage.setItem('playerName', myName);
            document.getElementById('myNameDisplay').innerText = myName;
            if (currentRoomId && currentUserKey) update(ref(db, `ongame_room/${currentRoomId}/users/${currentUserKey}`), { name: myName });
        }
    };

    function checkBoardWinner(data) {
        if(data.type === 'liar') return;

        const rows = data.rows || 3;
        const cols = data.cols || 3;
        const winTarget = data.winCondition || 3;
        const emptyVal = data.type === 'c4' ? 0 : "";
        const winner = checkWinGeneral(data.board, rows, cols, winTarget, emptyVal);
        const msgEl = document.getElementById('win-message');

        if (winner) {
            const userList = Object.values(data.users);
            let winnerName = (winner === 'X' || winner === 1) ? (userList[0]?.name||"P1") : (userList[1]?.name||"P2");
            msgEl.innerText = `ğŸ‰ æ­å–œ ${winnerName} ç²å‹ï¼ ğŸ‰`;
            msgEl.style.color = (winner === 'X' || winner === 1) ? '#ff4d4d' : '#ffd93d';
            document.getElementById('win-overlay').style.display = 'flex';
        } else if (data.type !== 'ttt-infinite') {
            const isFull = data.board.every(c => c !== 0 && c !== "");
            if (isFull) {
                msgEl.innerText = `ğŸ¤ å¹³æ‰‹ï¼ ğŸ¤`;
                msgEl.style.color = "white";
                document.getElementById('win-overlay').style.display = 'flex';
            } else {
                document.getElementById('win-overlay').style.display = 'none';
            }
        }
    }

    function checkWinGeneral(board, rows, cols, target, emptyVal) {
        const getCell = (r, c) => (r < 0 || r >= rows || c < 0 || c >= cols) ? null : board[r * cols + c];
        const directions = [[0, 1], [1, 0], [1, 1], [1, -1]];
        for(let r = 0; r < rows; r++) {
            for(let c = 0; c < cols; c++) {
                const current = getCell(r, c);
                if (current === emptyVal || current === null) continue;
                for (let [dr, dc] of directions) {
                    let count = 1;
                    for (let k = 1; k < target; k++) {
                        if (getCell(r + dr * k, c + dc * k) === current) count++; else break;
                    }
                    if (count === target) return current;
                }
            }
        }
        return null;
    }

    window.resetGame = () => {
        if (!roomDataCache) return;
        if (roomDataCache.type === 'liar') {
            startLiarGame(); // ç›´æ¥é‡é–‹ä¸€å±€
        } else {
            // æ£‹ç›¤é‡ç½®
            const rows = roomDataCache.rows || 3;
            const cols = roomDataCache.cols || 3;
            const initBoard = roomDataCache.type === 'c4' ? Array(rows*cols).fill(0) : Array(rows*cols).fill("");
            const history = roomDataCache.type === 'ttt-infinite' ? [{board:initBoard, moves:[]}] : [initBoard];
            update(ref(db, `ongame_room/${currentRoomId}`), { 
                board: initBoard, moves: [], turn: 0, history: history 
            });
        }
        closeWinOverlay();
    };

    window.closeWinOverlay = () => document.getElementById('win-overlay').style.display = 'none';
    window.showSection = (id) => {
        document.querySelectorAll('.container').forEach(c => c.classList.add('hidden'));
        document.getElementById(id).classList.remove('hidden');
    };
    window.leaveRoom = () => location.reload();
    window.deleteRoom = (id) => { if(confirm("ç¢ºå®šåˆªé™¤ï¼Ÿ")) remove(ref(db, 'ongame_room/' + id)); };
    
    // é¡è‰²åŒæ­¥
    const p1Picker = document.getElementById('p1ColorPicker');
    const p2Picker = document.getElementById('p2ColorPicker');
    const updateColors = () => {
        document.documentElement.style.setProperty('--p1-color', p1Picker.value);
        document.documentElement.style.setProperty('--p2-color', p2Picker.value);
    };
    p1Picker.addEventListener('input', updateColors);
    p2Picker.addEventListener('input', updateColors);
    p1Picker.addEventListener('change', () => {
        if(currentRoomId && roomDataCache.type === 'c4') update(ref(db, `ongame_room/${currentRoomId}`), { p1Color: p1Picker.value });
    });
    p2Picker.addEventListener('change', () => {
        if(currentRoomId && roomDataCache.type === 'c4') update(ref(db, `ongame_room/${currentRoomId}`), { p2Color: p2Picker.value });
    });

</script>
</body>
</html>
