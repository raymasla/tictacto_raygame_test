<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>æœ‰è¶£å°éŠæˆ²</title>
    <style>
        /* ========================================= */
        /* --- å…¨å±€æš—è‰²ç³»ä¸»é¡Œèˆ‡å‹•ç•« (Dark Theme) --- */
        /* ========================================= */
        :root {
            --bg-color: #0f172a;
            --container-bg: rgba(30, 41, 59, 0.85);
            --text-main: #e2e8f0;
            --text-muted: #94a3b8;
            --primary-grad: linear-gradient(135deg, #6366f1 0%, #a855f7 100%);
            --accent-green: #10b981;
            --accent-red: #ef4444;
            --accent-orange: #f59e0b;
            --glass-border: 1px solid rgba(255, 255, 255, 0.1);
            --shadow-glow: 0 0 15px rgba(99, 102, 241, 0.3);
        }

        body {
            font-family: 'PingFang TC', 'Microsoft JhengHei', sans-serif;
            background: linear-gradient(-45deg, #0f172a, #1e1b4b, #312e81, #0f172a);
            background-size: 400% 400%;
            animation: gradientBG 15s ease infinite;
            color: var(--text-main);
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            margin: 0;
            min-height: 100vh;
            touch-action: manipulation;
            overflow-x: hidden;
        }

        @keyframes gradientBG {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        /* å®¹å™¨ç¾åŒ– - ç»ç’ƒæ“¬æ…‹ */
        .container {
            background: var(--container-bg);
            padding: 25px;
            border-radius: 16px;
            box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: var(--glass-border);
            width: 100%;
            max-width: 550px;
            text-align: center;
            margin-bottom: 20px;
            position: relative;
            z-index: 10;
            transition: all 0.3s ease;
            animation: fadeIn Up 0.5s ease-out;
        }

        @keyframes fadeInUp {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        h1, h3, h4 { margin-top: 0; color: #fff; text-shadow: 0 2px 4px rgba(0,0,0,0.5); }
        .hidden { display: none !important; }

        /* --- æŒ‰éˆ•ç¾åŒ– --- */
        button { font-family: inherit; }
        .menu-btn {
            width: 100%; padding: 16px; margin: 12px 0; font-size: 18px; cursor: pointer;
            border: none; border-radius: 12px;
            background: var(--primary-grad);
            color: white; font-weight: bold;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative; overflow: hidden;
        }
        .menu-btn::after {
            content: ''; position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(rgba(255,255,255,0.2), transparent);
            opacity: 0; transition: 0.3s;
        }
        .menu-btn:hover { transform: translateY(-3px) scale(1.02); box-shadow: 0 8px 25px rgba(99, 102, 241, 0.5); }
        .menu-btn:hover::after { opacity: 1; }
        .menu-btn:active { transform: translateY(0); }

        .btn-c4 { background: linear-gradient(135deg, #3b82f6, #2563eb); }
        .btn-purple { background: linear-gradient(135deg, #8b5cf6, #7c3aed); }
        .btn-liar { background: linear-gradient(135deg, #f97316, #ea580c); box-shadow: 0 4px 15px rgba(234, 88, 12, 0.3); }
        .btn-liar:hover { box-shadow: 0 8px 25px rgba(234, 88, 12, 0.6); }

        /* å°æŒ‰éˆ• */
        .btn-sm { border: none; padding: 6px 14px; border-radius: 8px; cursor: pointer; font-size: 0.85em; margin-left: 6px; color: white; transition: 0.2s; font-weight: 600; }
        .btn-green { background: var(--accent-green); box-shadow: 0 2px 8px rgba(16, 185, 129, 0.3); }
        .btn-green:hover { background: #059669; }
        .btn-red { background: var(--accent-red); box-shadow: 0 2px 8px rgba(239, 68, 68, 0.3); }
        .btn-red:hover { background: #dc2626; }
        
        .btn-undo { 
            background: #475569; color: #cbd5e1; border: 1px solid #64748b; 
            padding: 10px 20px; border-radius: 30px; cursor: pointer; margin-top: 15px; 
            transition: 0.2s;
        }
        .btn-undo:hover { background: #64748b; color: white; }

        /* --- æˆ¿é–“åˆ—è¡¨é …ç›® --- */
        .room-item {
            border: 1px solid rgba(255,255,255,0.05);
            padding: 15px; margin: 12px 0;
            display: flex; justify-content: space-between; align-items: center;
            border-radius: 12px;
            background: rgba(0, 0, 0, 0.2);
            transition: 0.3s;
            animation: fadeIn 0.5s ease;
        }
        .room-item:hover { background: rgba(255, 255, 255, 0.05); border-color: rgba(255,255,255,0.2); transform: translateX(5px); }
        
        .room-info { text-align: left; display: flex; flex-direction: column; }
        .room-name { font-weight: bold; font-size: 1.1em; color: #fff; display: flex; align-items: center; gap: 5px; }
        .lock-icon { font-size: 0.8em; color: #f87171; }
        .room-meta { font-size: 0.8em; color: var(--text-muted); margin-top: 4px; }
        
        .status-badge { font-size: 0.75em; padding: 3px 8px; border-radius: 20px; margin-left: 8px; font-weight: bold; letter-spacing: 0.5px; }
        .status-wait { background: rgba(16, 185, 129, 0.2); color: #34d399; border: 1px solid rgba(16, 185, 129, 0.3); }
        .status-play { background: rgba(239, 68, 68, 0.2); color: #f87171; border: 1px solid rgba(239, 68, 68, 0.3); }

        /* --- çµ±è¨ˆèˆ‡è¼¸å…¥æ¡† --- */
        .stats-bar {
            background: rgba(0,0,0,0.2); padding: 12px; border-radius: 10px;
            margin-bottom: 20px; font-size: 0.95em; color: var(--text-muted);
            display: flex; justify-content: space-around; border: 1px solid rgba(255,255,255,0.05);
        }
        .stat-item b { color: #60a5fa; font-size: 1.2em; margin-left: 5px; }

        input {
            padding: 10px 15px; text-align: center; border: 1px solid #475569;
            border-radius: 8px; background: #1e293b; color: white; outline: none; transition: 0.3s;
        }
        input:focus { border-color: #8b5cf6; box-shadow: 0 0 0 3px rgba(139, 92, 246, 0.2); }
        
        .input-group { margin: 15px 0; text-align: left; display: flex; align-items: center; justify-content: space-between; color: var(--text-main); }
        .settings-row { display: flex; gap: 10px; margin: 10px 0; }
        .settings-item { flex: 1; display: flex; flex-direction: column; color: var(--text-muted); font-size: 0.9em; }
        .settings-item input { margin-top: 5px; width: 100%; box-sizing: border-box; }

        /* é¨™å­è¦å‰‡å€å¡Šå„ªåŒ– */
        #liarSettings {
            background: rgba(67, 20, 7, 0.4) !important;
            border: 1px solid rgba(234, 88, 12, 0.3);
            border-left: 5px solid #ea580c !important;
            color: #fdba74;
        }
        #liarSettings h4 { color: #fb923c !important; }

        /* --- èŠå¤©å®¤å„ªåŒ– --- */
        #chat-area { margin-top: 20px; border-top: 1px solid rgba(255,255,255,0.1); padding-top: 15px; text-align: left; }
        #chat-msgs {
            height: 120px; overflow-y: auto; background: rgba(0,0,0,0.3);
            border-radius: 8px; padding: 10px; font-size: 0.9em; margin-bottom: 10px;
            border: 1px solid rgba(255,255,255,0.05); color: var(--text-main);
        }
        #chat-msgs div { margin-bottom: 4px; animation: fadeIn 0.3s; }
        #chat-msgs b { color: #a5b4fc; margin-right: 5px; }
        
        .chat-input-group { display: flex; gap: 8px; }
        .chat-input-group input { flex: 1; text-align: left; background: rgba(0,0,0,0.4); }
        .chat-input-group button { 
            background: #334155; border: 1px solid #475569; color: white; 
            padding: 0 15px; border-radius: 8px; cursor: pointer; transition: 0.2s; 
        }
        .chat-input-group button:hover { background: #475569; }
        .editable-name { color: #60a5fa; font-weight: bold; cursor: pointer; border-bottom: 1px dashed #60a5fa; transition: 0.2s; }
        .editable-name:hover { color: #93c5fd; border-color: #93c5fd; }

        /* æµ®å‹•èŠå¤© (Danmaku) */
        .floating-chat-container {
            position: absolute; top: 0; left: 0; width: 100%; height: 60%;
            pointer-events: none; overflow: hidden; z-index: 900;
        }
        .float-msg {
            position: absolute; left: 50%; transform: translateX(-50%);
            background: rgba(139, 92, 246, 0.8); color: white;
            padding: 6px 16px; border-radius: 20px; font-weight: bold;
            font-size: 1.1em; white-space: nowrap;
            box-shadow: 0 4px 10px rgba(0,0,0,0.3);
            animation: floatUpFade 4s forwards;
            border: 1px solid rgba(255,255,255,0.2);
            backdrop-filter: blur(4px);
        }
        @keyframes floatUpFade {
            0% { opacity: 0; bottom: 10%; transform: translateX(-50%) scale(0.8); }
            10% { opacity: 1; transform: translateX(-50%) scale(1); }
            80% { opacity: 1; }
            100% { opacity: 0; bottom: 85%; transform: translateX(-50%); }
        }

        /* --- æ£‹ç›¤éŠæˆ²æ¨£å¼ (Dark Board) --- */
        #gameArea { transition: 0.3s; }
        :root { --c4-cell-size: 40px; --p1-color: #f87171; --p2-color: #facc15; }
        
        #c4-game-wrapper {
            display: flex; flex-direction: column; align-items: center;
            background-color: #1e293b; 
            padding: 20px; border-radius: 16px; overflow-x: auto;
            border: 2px solid #334155;
            box-shadow: inset 0 0 20px rgba(0,0,0,0.5);
        }
        .c4-board { 
            display: grid; gap: 6px; padding: 12px; 
            background: #0f172a; border-radius: 12px; border: 2px solid #1e293b;
        }
        .c4-cell { 
            width: var(--c4-cell-size); height: var(--c4-cell-size); 
            background-color: #334155; border-radius: 50%; 
            box-shadow: inset 2px 2px 5px rgba(0,0,0,0.4);
        }
        .piece { 
            width: 100%; height: 100%; border-radius: 50%; 
            animation: dropAnim 0.5s cubic-bezier(0.5, 0, 0.75, 0) forwards; 
            box-shadow: inset -2px -2px 5px rgba(0,0,0,0.2), 0 0 10px currentColor; 
        }
        .p1 { background: var(--p1-color); color: var(--p1-color); } 
        .p2 { background: var(--p2-color); color: var(--p2-color); }
        @keyframes dropAnim { from { transform: translateY(-300px); opacity: 0; } to { transform: translateY(0); opacity: 1; } }
        
        #ttt-board { 
            display: grid; gap: 8px; margin: 15px auto; 
            background: #334155; padding: 8px; border-radius: 12px; 
            max-width: 300px;
        }
        .ttt-cell { 
            background: #1e293b; min-width: 50px; min-height: 50px; aspect-ratio: 1/1; 
            display: flex; align-items: center; justify-content: center; 
            font-size: 2rem; font-weight: bold; cursor: pointer; position: relative;
            border-radius: 8px; color: #fff; transition: 0.2s;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        .ttt-cell:hover { background: #2d3e52; }
        .about-to-die { opacity: 0.4; color: #ef4444; border: 2px dashed #ef4444; box-sizing: border-box; }

        /* ========================================= */
        /* --- ç§»æ¤ç‰ˆ é¨™å­æ¡ŒéŠ (Liar's Deck) æ¨£å¼ --- */
        /* ========================================= */
        #liar-wrapper {
            background: radial-gradient(circle, #064e3b 0%, #022c22 100%);
            border: 10px solid #3f2e26;
            border-radius: 20px;
            box-shadow: inset 0 0 100px rgba(0,0,0,0.8), 0 15px 40px rgba(0,0,0,0.6);
            padding: 10px;
            color: #ecf0f1;
            position: relative;
            min-height: 580px;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            overflow: hidden;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
        }
        
        /* é ‚éƒ¨è³‡è¨Š */
        .liar-header {
            display: flex; justify-content: space-between; align-items: center;
            background: rgba(0,0,0,0.6); padding: 8px 15px; border-radius: 30px;
            border: 1px solid rgba(255,255,255,0.1); backdrop-filter: blur(5px);
        }
        .target-card-display {
            font-size: 1.4em; font-weight: 800; padding: 5px 20px;
            background: linear-gradient(to bottom, #fcd34d, #d97706); color: #451a03; 
            border-radius: 8px; border: 2px solid #fff; 
            box-shadow: 0 0 15px rgba(251, 191, 36, 0.6);
            text-shadow: none; animation: popIn 0.3s;
        }

        /* ç‰Œæ¡Œä¸­å¤® */
        .liar-table-center {
            flex: 1; position: relative;
            display: flex; justify-content: center; align-items: center;
            perspective: 800px;
            flex-direction: column; 
        }
        
        /* å¡ç‰Œè¨­è¨ˆ */
        .card {
            width: 55px; height: 80px;
            background: #e2e2e2; border-radius: 6px;
            box-shadow: 2px 4px 10px rgba(0,0,0,0.6);
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            font-weight: bold; font-size: 1.2em; position: relative;
            user-select: none; border: 1px solid #999;
            transition: transform 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            text-shadow: none;
        }
        .card.red { color: #dc2626; }
        .card.black { color: #1e293b; }
        .card.joker { color: #7c3aed; border: 2px solid #facc15; }
        .card-back {
            background: repeating-linear-gradient(45deg, #7f1d1d, #7f1d1d 10px, #991b1b 10px, #991b1b 20px);
            border: 2px solid #e5e7eb;
        }
        .card-back::after { content: "âšœï¸"; color: rgba(255,255,255,0.4); font-size: 24px; }

        /* å°æ‰‹å€ */
        .opponents-row { display: flex; justify-content: space-around; width: 100%; margin-top: 10px; }
        .opponent {
            background: rgba(0,0,0,0.7); padding: 8px; border-radius: 12px;
            text-align: center; width: 85px; position: relative;
            transition: 0.3s; border: 2px solid transparent;
            box-shadow: 0 4px 10px rgba(0,0,0,0.3);
        }
        .opponent.active { 
            border-color: #facc15; background: rgba(250, 204, 21, 0.15); 
            transform: scale(1.1); box-shadow: 0 0 15px rgba(250, 204, 21, 0.4);
        }
        .opponent.dead { opacity: 0.6; filter: grayscale(100%); border: 1px solid #555; }
        .opponent.escaped { border-color: #10b981; opacity: 0.9; box-shadow: 0 0 10px #10b981; }
        .opponent.offline { opacity: 0.5; border: 1px dashed #94a3b8; }
        
        /* æ§è†›é¡¯ç¤º */
        .cylinder-display {
            display: flex; justify-content: center; gap: 3px; margin-top: 5px;
        }
        .bullet-slot { width: 8px; height: 8px; border-radius: 50%; background: #4b5563; border: 1px solid #6b7280; }
        .bullet-slot.fired { background: #111; box-shadow: inset 0 0 2px rgba(255,255,255,0.2); }
        .bullet-slot.live { background: #ef4444; box-shadow: 0 0 6px #ef4444; }

        /* æˆ‘çš„æ§æç‹€æ…‹é¡¯ç¤º */
        .my-gun-status {
            position: absolute; bottom: 140px; right: 10px;
            background: rgba(0, 0, 0, 0.85); padding: 10px;
            border-radius: 12px; color: white; text-align: center;
            border: 1px solid #4b5563;
            box-shadow: 0 4px 15px rgba(0,0,0,0.5); z-index: 50;
        }

        /* æ‰‹ç‰Œå€ */
        .my-hand-area {
            height: 110px; display: flex; justify-content: center; align-items: center; gap: -10px;
            padding-bottom: 10px; z-index: 20;
        }
        .my-hand-area .card { margin: 0 4px; cursor: pointer; transform-origin: bottom center; }
        .my-hand-area .card:hover { transform: translateY(-20px) scale(1.15); z-index: 50; box-shadow: 0 10px 20px rgba(0,0,0,0.5); }
        .my-hand-area .card.selected { transform: translateY(-30px); border: 3px solid #facc15; box-shadow: 0 0 20px #facc15; }

        /* éŠæˆ²æŒ‰éˆ•å€ */
        .liar-controls { display: flex; gap: 15px; justify-content: center; margin-bottom: 10px; height: 50px; }
        .btn-game { 
            padding: 0 28px; border-radius: 30px; border: none; font-weight: 800; cursor: pointer; 
            font-size: 1.1em; color: white; box-shadow: 0 6px 0 rgba(0,0,0,0.4); 
            transition: 0.1s; text-transform: uppercase; letter-spacing: 1px;
        }
        .btn-game:active { transform: translateY(4px); box-shadow: none; }
        .btn-game:disabled { background: #64748b; cursor: not-allowed; box-shadow: none; transform: translateY(4px); filter: grayscale(0.8); }

        .btn-play { 
            background: linear-gradient(to bottom, #3b82f6, #1d4ed8); 
            font-size: 1.4em; 
            padding: 0 40px; 
            min-width: 120px; 
        }
        
        .btn-liar-call { background: linear-gradient(to bottom, #ef4444, #b91c1c); font-size: 1.3em; letter-spacing: 2px; }

        /* --- å‹•ç•«ç‰¹æ•ˆå±¤ --- */
        #intro-overlay {
            position: absolute; top:0; left:0; width:100%; height:100%;
            background: rgba(0,0,0,0.9); z-index: 300;
            display: none; flex-direction: row; align-items: center; justify-content: center;
            gap: 20px; backdrop-filter: blur(5px);
        }
        .intro-grid {
            display: grid; grid-template-columns: repeat(6, 1fr); gap: 8px;
        }
        .intro-side {
            display: flex; flex-direction: column; gap: 10px; margin-left: 20px; padding-left: 20px; border-left: 2px dashed rgba(255,255,255,0.3);
        }
        .intro-card-sm {
            width: 32px; height: 48px; background: white; border-radius: 4px;
            font-size: 0.9em; display: flex; align-items: center; justify-content: center; font-weight: bold;
            box-shadow: 0 2px 5px rgba(0,0,0,0.5);
            animation: popIn 0.3s backwards;
        }
        @keyframes popIn { 0%{transform:scale(0); opacity:0;} 100%{transform:scale(1); opacity:1;} }

        .reveal-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9); z-index: 100;
            display: none; flex-direction: column; align-items: center; justify-content: center;
            backdrop-filter: blur(8px);
        }
        .reveal-stage { display: flex; gap: 15px; margin: 30px 0; perspective: 1000px; }
        .reveal-card-wrapper { width: 70px; height: 100px; position: relative; transform-style: preserve-3d; transition: transform 0.6s; }
        .reveal-card-wrapper.flipped { transform: rotateY(180deg); }
        .reveal-face, .reveal-back {
            position: absolute; width: 100%; height: 100%; backface-visibility: hidden;
            border-radius: 8px; display: flex; align-items: center; justify-content: center;
            font-size: 1.8em; font-weight: bold; text-shadow: none;
        }
        .reveal-back { background: repeating-linear-gradient(45deg, #7f1d1d, #7f1d1d 5px, #991b1b 5px, #991b1b 10px); border: 2px solid white; box-shadow: 0 4px 10px black; }
        .reveal-face { background: white; transform: rotateY(180deg); border: 4px solid transparent; }
        .reveal-face.correct { border-color: #10b981; box-shadow: 0 0 30px #10b981; }
        .reveal-face.wrong { border-color: #ef4444; box-shadow: 0 0 30px #ef4444; color: #ef4444; }

        .gun-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 200; pointer-events: none; display: none;
            align-items: center; justify-content: center; flex-direction: column;
        }
        .gun-visual { font-size: 8em; filter: drop-shadow(0 0 20px rgba(0,0,0,0.8)); animation: gunAim 1s ease-in-out infinite alternate; }
        .bang-visual { 
            position: absolute; font-size: 10em; color: #facc15; font-weight: 900; 
            text-shadow: 0 0 20px #ef4444, 0 0 40px #b91c1c; opacity: 0; transform: scale(0);
        }
        .bang-animate { animation: bangPop 0.3s forwards; }

        @keyframes gunAim { from { transform: rotate(-5deg); } to { transform: rotate(5deg); } }
        @keyframes bangPop { 0% { opacity: 0; transform: scale(0.5); } 50% { opacity: 1; transform: scale(1.5); } 100% { opacity: 0; transform: scale(2); } }
        @keyframes shake { 0% { transform: translate(1px, 1px) rotate(0deg); } 10% { transform: translate(-1px, -2px) rotate(-1deg); } 20% { transform: translate(-3px, 0px) rotate(1deg); } 30% { transform: translate(3px, 2px) rotate(0deg); } 40% { transform: translate(1px, -1px) rotate(1deg); } 50% { transform: translate(-1px, 2px) rotate(-1deg); } 60% { transform: translate(-3px, 1px) rotate(0deg); } 70% { transform: translate(3px, 1px) rotate(-1deg); } 80% { transform: translate(-1px, -1px) rotate(1deg); } 90% { transform: translate(1px, 2px) rotate(0deg); } 100% { transform: translate(1px, -2px) rotate(-1deg); } }
        .shaking { animation: shake 0.5s; }

        /* --- å‹åˆ©ç‰¹æ•ˆ & å·¨å¤§æŒ‰éˆ• (Dark Version) --- */
        #win-overlay { 
            position: fixed; top: 0; left: 0; width: 100%; height: 100%; 
            background: rgba(15, 23, 42, 0.95); display: none; 
            flex-direction: column; justify-content: center; align-items: center; 
            z-index: 1000; color: white; backdrop-filter: blur(10px);
        }
        #win-message { 
            font-size: 3.5em; margin-bottom: 20px; 
            background: linear-gradient(to right, #facc15, #f59e0b);
            -webkit-background-clip: text; -webkit-text-fill-color: transparent;
            text-shadow: 0 0 30px rgba(245, 158, 11, 0.4); text-align: center; padding: 0 20px;
            animation: popIn 0.5s;
        }
        .big-reset-btn { 
            padding: 20px 50px; font-size: 24px; font-weight: bold; 
            background: var(--accent-green); color: white; border: none; border-radius: 50px; 
            cursor: pointer; box-shadow: 0 0 30px rgba(16, 185, 129, 0.5); 
            transition: 0.3s; margin-top: 20px; text-transform: uppercase;
        }
        .big-reset-btn:hover { transform: scale(1.1); box-shadow: 0 0 50px rgba(16, 185, 129, 0.8); }
        .waiting-text { animation: pulse 1.5s infinite; color: #facc15; }
        @keyframes pulse { 0% { opacity: 0.6; } 50% { opacity: 1; text-shadow: 0 0 10px #facc15; } 100% { opacity: 0.6; } }

        /* --- Qç‰ˆè¼¸å…¥æš±ç¨± Modal æ¨£å¼ --- */
        .modal-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.7); z-index: 2000;
            display: flex; justify-content: center; align-items: center;
            backdrop-filter: blur(5px);
            animation: fadeIn 0.3s;
        }
        .modal-box {
            background: linear-gradient(145deg, #1e293b, #0f172a);
            border: 2px solid #a78bfa;
            padding: 25px; border-radius: 20px;
            text-align: center; width: 90%; max-width: 350px;
            box-shadow: 0 0 25px rgba(139, 92, 246, 0.4);
            animation: popIn 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            color: #fff;
        }
        .modal-box h3 {
            color: #a78bfa; margin-bottom: 20px; font-size: 1.3em;
            text-shadow: 0 2px 10px rgba(167, 139, 250, 0.3);
        }
        .modal-input-wrapper input {
            width: 80%; font-size: 1.1em; padding: 12px; margin-bottom: 20px;
            border: 2px solid #475569; background: #334155; color: white;
            border-radius: 12px;
        }
        .modal-input-wrapper input:focus {
            border-color: #facc15; box-shadow: 0 0 15px rgba(250, 204, 21, 0.3);
        }
        .modal-btns {
            display: flex; justify-content: center; gap: 15px;
        }
        .modal-btn {
            padding: 10px 25px; border-radius: 25px; border: none; font-weight: bold; cursor: pointer;
            color: white; font-size: 1em; transition: 0.2s;
        }
        .modal-btn-confirm { background: var(--accent-green); box-shadow: 0 4px 0 #059669; }
        .modal-btn-confirm:active { transform: translateY(4px); box-shadow: none; }
        .modal-btn-cancel { background: #64748b; box-shadow: 0 4px 0 #475569; }
        .modal-btn-cancel:active { transform: translateY(4px); box-shadow: none; }

        /* æ»¾å‹•æ¢ç¾åŒ– */
        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: rgba(0,0,0,0.1); }
        ::-webkit-scrollbar-thumb { background: #475569; border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: #64748b; }

        /* ========== UNO éŠæˆ²å€ (æé¨™å­æ¡ŒéŠé¢¨æ ¼) ========== */
        :root {
            --uno-card-w: 56px; /* é è¨­èª¿å° */
            --uno-card-h: 84px; /* é è¨­èª¿å° */
            --uno-red: #ef4444;
            --uno-blue: #3b82f6;
            --uno-green: #10b981;
            --uno-yellow: #fbbf24;
        }
        #uno-wrapper {
            background: radial-gradient(circle, #1e3a5f 0%, #0f172a 100%);
            border: 8px solid #334155;
            border-radius: 20px;
            box-shadow: inset 0 0 60px rgba(0,0,0,0.6), 0 12px 30px rgba(0,0,0,0.5);
            padding: 10px;
            min-height: 520px;
            display: flex;
            flex-direction: column;
        }
        .uno-layout { display: flex; flex-direction: column; min-height: 480px; }
        .uno-header {
            display: flex; justify-content: space-between; align-items: center;
            background: rgba(0,0,0,0.5); padding: 8px 15px; border-radius: 20px;
            border: 1px solid rgba(255,255,255,0.1); margin-bottom: 10px;
        }
        .uno-room-info { font-size: 0.9rem; color: #cbd5e1; }
        .uno-header-btns { display: flex; align-items: center; gap: 8px; flex-wrap: wrap; }
        
        .uno-table-area {
            flex: 1; position: relative; display: flex; justify-content: center; align-items: center;
            gap: 30px; perspective: 800px; min-height: 220px; 
            padding: 50px 10px 30px 10px; 
            box-sizing: border-box;
        }
        .uno-opponents-bar {
            position: absolute; top: 10px; left: 0; right: 0;
            display: flex; gap: 8px; justify-content: center; flex-wrap: wrap;
            z-index: 10;
        }
        .uno-opponent-card {
            background: rgba(0,0,0,0.6); border: 1px solid rgba(255,255,255,0.15);
            border-radius: 10px; padding: 6px 12px; min-width: 60px;
            display: flex; flex-direction: column; align-items: center; transition: 0.3s;
        }
        .uno-opponent-card.active { border-color: var(--uno-yellow); background: rgba(251, 191, 36, 0.2); transform: scale(1.05); }
        .uno-opponent-card .opp-name { font-size: 0.7rem; color: #e2e8f0; max-width: 70px; overflow: hidden; text-overflow: ellipsis; }
        .uno-opponent-card .opp-count { font-size: 1.1rem; font-weight: bold; color: #fff; }
        .uno-direction-indicator {
            position: absolute; width: 200px; height: 200px;
            border: 2px dashed rgba(255,255,255,0.1); border-radius: 50%;
            pointer-events: none; opacity: 0.25;
            animation: unoSpin 10s linear infinite;
        }
        @keyframes unoSpin { 100% { transform: rotate(360deg); } }
        .uno-pile {
            width: var(--uno-card-w); height: var(--uno-card-h); border-radius: 10px;
            position: relative; cursor: pointer; transition: transform 0.2s;
            box-shadow: 0 8px 20px rgba(0,0,0,0.5);
            display: flex; justify-content: center; align-items: center; font-size: 0.85em; color: rgba(255,255,255,0.6);
        }
        .uno-deck {
            background: repeating-linear-gradient(45deg, #334155, #334155 8px, #1e293b 8px, #1e293b 16px);
            border: 2px solid #64748b;
        }
        .uno-discard { border: 2px dashed rgba(255,255,255,0.2); }
        
        #uno-center-message {
            position: absolute; bottom: 10px; font-weight: bold; color: #facc15;
            text-shadow: 0 2px 4px black; font-size: 14px;
            background: rgba(0,0,0,0.6); padding: 5px 12px; border-radius: 20px;
            z-index: 10;
        }
        .uno-bottom-section {
            background: linear-gradient(to top, rgba(0,0,0,0.8), transparent);
            padding: 10px 0 15px 0; border-radius: 0 0 12px 12px;
        }
        .uno-controls { display: flex; gap: 15px; justify-content: center; margin-bottom: 5px; flex-wrap: wrap; }
        .uno-controls .btn-game { min-width: 90px; padding: 10px 20px; font-size: 1em; }
        .uno-controls .btn-game.btn-secondary { background: linear-gradient(to bottom, #475569, #334155); color: white; }
        
        .uno-hand-scroll {
            display: flex; align-items: flex-end;
            overflow-x: auto; padding: 45px 15px 20px 15px; min-height: 130px; gap: 0;
            -webkit-overflow-scrolling: touch;
        }
        .uno-hand-scroll::before, .uno-hand-scroll::after {
            content: ''; margin: auto;
        }
        
        .uno-card {
            width: var(--uno-card-w); height: var(--uno-card-h); border-radius: 8px;
            position: relative; display: flex; justify-content: center; align-items: center;
            box-shadow: -2px 0 6px rgba(0,0,0,0.4); border: 2px solid white;
            user-select: none; transition: transform 0.2s; cursor: pointer;
            flex-shrink: 0; margin-left: -28px; transform-origin: center bottom;
        }
        .uno-card:first-of-type { margin-left: 0 !important; }
        .uno-card:hover { transform: translateY(-20px) scale(1.08); z-index: 50; box-shadow: 0 6px 18px rgba(0,0,0,0.5); }
        .uno-card.selected { transform: translateY(-35px) scale(1.12); z-index: 49; border-color: var(--uno-yellow); box-shadow: 0 0 20px var(--uno-yellow); }
        .uno-card.disabled { filter: grayscale(0.7) brightness(0.5); cursor: not-allowed; pointer-events: none; }
        .uno-card .card-oval { width: 85%; height: 58%; background: white; border-radius: 50% / 45%; transform: rotate(-30deg); display: flex; align-items: center; justify-content: center; }
        .uno-card .card-symbol { font-family: 'Arial Black'; font-size: 1.8em; }
        .uno-card .corner { position: absolute; font-family: 'Arial Black'; font-size: 0.85em; color: white; text-shadow: 1px 1px 2px black; }
        .uno-card .tl { top: 3px; left: 5px; }
        .uno-card .br { bottom: 3px; right: 5px; transform: rotate(180deg); }
        .uno-bg-red { background: var(--uno-red); }
        .uno-bg-blue { background: var(--uno-blue); }
        .uno-bg-green { background: var(--uno-green); }
        .uno-bg-yellow { background: var(--uno-yellow); }
        .uno-bg-black { background: #1e293b; border-color: #64748b; }
        .uno-bg-wild { background: conic-gradient(from 180deg, var(--uno-red) 0% 25%, var(--uno-blue) 25% 50%, var(--uno-green) 50% 75%, var(--uno-yellow) 75% 100%); color: black; }
        .uno-tint-red { background: var(--uno-red) !important; }
        .uno-tint-blue { background: var(--uno-blue) !important; }
        .uno-tint-green { background: var(--uno-green) !important; }
        .uno-tint-yellow { background: var(--uno-yellow) !important; }
        .uno-color-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; margin-top: 15px; }
        .uno-color-btn { height: 70px; border-radius: 12px; border: 3px solid white; cursor: pointer; transition: 0.2s; box-shadow: 0 4px 12px rgba(0,0,0,0.3); }
        .uno-color-btn:hover { transform: scale(1.05); }
        #uno-shout { animation: unoShoutPop 1.5s forwards; }
        @keyframes unoShoutPop {
            0% { transform: translate(-50%,-50%) scale(0); opacity: 0; }
            20% { opacity: 1; }
            60% { transform: translate(-50%,-50%) scale(1.2); opacity: 1; }
            100% { transform: translate(-50%,-50%) scale(1); opacity: 0; }
        }

    </style>
</head>
<body>

<div id="mainMenu" class="container">
    <h1 style="background: linear-gradient(to right, #60a5fa, #a78bfa); -webkit-background-clip: text; -webkit-text-fill-color: transparent;">ğŸ® éŠæˆ²å¤§å»³</h1>
    <div class="stats-bar">
        <div class="stat-item">å¤§å»³é–’ç½®: <b id="lobbyCount">0</b></div>
        <div class="stat-item">éŠæˆ²ä¸­: <b id="inGameCount">0</b></div>
    </div>

    <div id="allRoomsContainer">æœå°‹ä¸­...</div>
    <hr style="border-color: rgba(255,255,255,0.1); margin: 20px 0;">
    <button class="menu-btn" onclick="showCreateRoom('ttt')">å‰µç«‹ åœˆåœˆå‰å‰ â­•âŒ</button>
    <button class="menu-btn btn-c4" onclick="showCreateRoom('c4')">å‰µç«‹ å››é€£æ£‹ (ğŸ”´ğŸ”µ)</button>
    <button class="menu-btn btn-liar" onclick="showCreateRoom('liar')">å‰µç«‹ é¨™å­æ¡ŒéŠ ğŸ”«ğŸƒ</button>
    <button class="menu-btn" style="background: linear-gradient(135deg, #f59e0b, #ef4444);" onclick="showCreateRoom('uno')">å‰µç«‹ UNO ğŸƒ</button>
    <hr style="border: 0; height: 1px; background: rgba(255,255,255,0.2); margin: 15px 0;">
    <button class="menu-btn btn-purple" onclick="window.open('https://raymasla.github.io/whois/')">
    å‰å¾€ èª°æ˜¯è‡¥åº•ğŸ•µï¸
</button>
    <button class="menu-btn" style="background: linear-gradient(135deg, #1e3a8a 0%, #1e40af 100%);" onclick="window.open('https://raymasla.github.io/Yahtzee-online/', '_blank')">
    å‰å¾€ YahtzeeğŸ²</button>
    <button class="menu-btn" style="background: linear-gradient(to right, #FF8080 0%, #FF0000 100%); color: white; border: none; padding: 10px 25px; border-radius: 8px; font-weight: bold; cursor: pointer; box-shadow: 0 4px 6px rgba(0,0,0,0.1);" onclick="window.open('https://reurl.cc/vkmlg1', '_blank')">
    ğŸ˜è¨‚é–±é˜¿å¡GameğŸ˜
</button>
</div>

<div id="createRoomSection" class="container hidden">
    <h3 id="createTitle">å‰µç«‹æˆ¿é–“</h3>
    
    <div class="input-group"><label>æˆ¿é–“åç¨±:</label><input type="text" id="roomName" placeholder="æœªå‘½åæˆ¿é–“"></div>
    <div class="input-group"><label>è¨­å®šå¯†ç¢¼:</label><input type="password" id="roomPass" placeholder="å¯ç•™ç©º"></div>

    <hr style="margin: 15px 0; border: 0; border-top: 1px solid rgba(255,255,255,0.1);">
    
    <div id="normalSettings">
        <div style="text-align: left; font-weight: bold; margin-bottom: 5px; color:#cbd5e1;">éŠæˆ²è¦å‰‡è¨­å®š:</div>
        <div class="settings-row">
            <div class="settings-item">
                <label>é«˜ (Rows)</label>
                <input type="number" id="inputRows" min="3" max="15" value="3">
            </div>
            <div class="settings-item">
                <label>å¯¬ (Cols)</label>
                <input type="number" id="inputCols" min="3" max="15" value="3">
            </div>
            <div class="settings-item">
                <label>é€£ç·šæ•¸</label>
                <input type="number" id="inputWin" min="3" max="10" value="3">
            </div>
        </div>
        <div id="infinite-hint" style="font-size: 0.85em; color: #a78bfa; margin-bottom: 10px; display:none; background: rgba(139, 92, 246, 0.1); padding: 8px; border-radius: 6px;">
            â€» ç„¡é™æ¨¡å¼ï¼šé›™æ–¹æœ€å¤š 3 é¡†æ£‹å­ï¼Œä¸‹ç¬¬ 4 é¡†æœ€æ—©çš„æ¶ˆå¤±ã€‚
        </div>
    </div>

    <div id="unoSettings" class="hidden" style="text-align: left; font-size: 0.9em; padding:15px; border-radius:8px; margin:15px 0; background: rgba(245, 158, 11, 0.1); border: 1px solid rgba(245, 158, 11, 0.3); border-left: 5px solid #f59e0b;">
        <h4 style="margin:0 0 8px 0; color:#fbbf24;">ğŸƒ UNO è¦å‰‡è¨­å®š</h4>
        <label style="display:block; margin:8px 0;"><input type="checkbox" id="uno-rule-chain" style="margin-right:6px;"> é€£å‡º (Chain)</label>
        <label style="display:block; margin:8px 0;"><input type="checkbox" id="uno-rule-stack" style="margin-right:6px;"> ç–ŠåŠ  (Stack +2/+4)</label>
        <div class="input-group" style="margin-top:10px;"><label>åˆå§‹æ‰‹ç‰Œå¼µæ•¸:</label><input type="number" id="uno-initialHandSize" min="1" max="20" value="7" style="width:80px;"></div>
    </div>

    <div id="liarSettings" class="hidden" style="text-align: left; font-size: 0.9em; padding:15px; border-radius:8px; margin:15px 0;">
        <h4 style="margin:0 0 5px 0;">ğŸ”« é¨™å­é…’é¤¨è¦å‰‡ï¼š</h4>
        1. ç‰Œåº«å« A, Q, K (å„6å¼µ) + Joker (2å¼µ)ã€‚<br>
        2. ç³»çµ±æŒ‡å®šç›®æ¨™ (å¦‚ King)ï¼Œç©å®¶å¿…é ˆå‡ºç‰Œä¸¦å®£ç¨±ç¬¦åˆã€‚<br>
        3. è‹¥æ‡·ç–‘ä¸Šå®¶èªªè¬Šï¼Œå¯æŒ‰ä¸‹ <b style="color:#ef4444">LIAR!</b> æŠ“è¬Šã€‚<br>
        4. <b>æŠ“å°äº†</b>ï¼šèªªè¬Šè€…æ¥å—å·¦è¼ªåˆ¶è£ï¼›<b>æŠ“éŒ¯äº†</b>ï¼šæŠ“äººè€…æ¥å—åˆ¶è£ã€‚<br>
        5. <b>å‡ºå®Œç‰Œ</b>ï¼š3äººä»¥ä¸Šæ™‚ï¼Œå®‰å…¨ä¸Šå²¸ (è·³éå›åˆ)ï¼›è‹¥å‰©å…©äººæ™‚ä¸Šå®¶å‡ºå®Œç‰Œï¼Œä¸‹å®¶å¿…é ˆå¼·åˆ¶æŠ“è¬Šã€‚<br>
        6. 1/6 æ©Ÿç‡è§¸ç™¼å¯¦å½ˆï¼Œæ­»äº¡æ·˜æ±°ã€‚<br>
        7. <b style="color:#facc15">å¤šäººæ¨¡å¼(5äºº+)</b>: ç‰Œåº«è‡ªå‹•æ“´å……è‡³ 8çµ„ A,Q,K + 4 Jokerã€‚<br>
        8. <b style="color:#60a5fa">æ–·ç·šä¿è­·</b>: é›¢é–‹æˆ¿é–“å¾Œï¼Œæš±ç¨±èˆ‡éŠæˆ²é€²åº¦å°‡ä¿ç•™ï¼Œé‡æ–°è¼¸å…¥åŒåå³å¯å›åˆ°åº§ä½ã€‚<br>
        
        <label style="display:block; margin-top:10px; color:#facc15; font-weight:bold; cursor:pointer; padding:5px; border:1px dashed rgba(250, 204, 21, 0.5); border-radius:5px;">
            <input type="checkbox" id="checkAnytimeLiar" style="width:auto; vertical-align:middle; margin-right:5px;">
            ğŸ”“ é–‹å•Ÿã€Œéš¨æ™‚æŠ“è¬Šã€æ¨¡å¼ (æ‰€æœ‰äººçš†å¯æŠ“è¬Š)
        </label>
    </div>

    <button id="btn-confirm" class="menu-btn" onclick="createRoom()">ç¢ºèªå‰µç«‹</button>
    <button id="btn-infinite" class="menu-btn btn-purple hidden" onclick="createInfiniteRoom()">å‰µç«‹ ç„¡é™åœˆåœˆå‰å‰ (åªç•™ä¸‰å­)</button>
    
    <button class="btn-sm" style="background:transparent; border:1px solid #64748b; margin-top:10px; color:#cbd5e1;" onclick="showSection('mainMenu')">è¿”å›å¤§å»³</button>
</div>

<div id="gameArea" class="container hidden">
    <div style="display:flex; justify-content:space-between; align-items:center;">
        <h3 id="roomDisplayInfo" style="margin:5px 0; color: #fff;"></h3>
        <button class="btn-sm btn-red" onclick="leaveRoom()">é›¢é–‹æˆ¿é–“</button>
    </div>
    <div id="gameMetaInfo" style="font-size: 0.85em; color: #94a3b8; margin-bottom: 10px;"></div>
    
    <div id="status" style="font-weight: bold; color: #f87171; margin: 10px 0; font-size: 1.1em; text-shadow: 0 0 10px rgba(248, 113, 113, 0.3);">è¼‰å…¥ä¸­...</div>
    
    <div id="floating-chat-zone" class="floating-chat-container"></div>

    <div id="ttt-board" class="hidden"></div>
    <div id="c4-game-wrapper" class="hidden">
        <div class="color-pickers" style="margin-bottom: 10px; font-size: 0.9em; color: #cbd5e1;">
            <label class="color-label">P1è‰²: <input type="color" id="p1ColorPicker" value="#f87171" style="padding:0; width:30px; height:30px; border:none; vertical-align:middle;"></label>
            <label class="color-label" style="margin-left:15px;">P2è‰²: <input type="color" id="p2ColorPicker" value="#facc15" style="padding:0; width:30px; height:30px; border:none; vertical-align:middle;"></label>
        </div>
        <div id="c4-board" class="c4-board"></div>
    </div>

    <div id="liar-wrapper" class="hidden">
        <div class="liar-header">
            <span id="liar-status-text" style="font-size:0.9em; font-weight:bold;">ç­‰å¾…ç©å®¶...</span>
            <div id="liar-target-display" class="target-card-display hidden">K</div>
        </div>
        
        <div class="opponents-row" id="liar-opponents"></div>

        <div class="liar-table-center">
            <div id="last-move-info" style="margin-bottom: 10px; font-size:1.1em; color:#fff; background:#ea580c; padding:6px 20px; border-radius:20px; box-shadow: 0 4px 10px rgba(234, 88, 12, 0.5); z-index: 10; font-weight: bold;"></div>
            
            <div id="liar-stack-area" style="position:relative; width:60px; height:90px; border: 2px dashed rgba(255,255,255,0.2); border-radius:6px;">
            </div>
        </div>
        
        <div id="my-gun-status" class="my-gun-status hidden"></div>

        <div class="my-hand-area" id="liar-my-hand"></div>
        
        <div class="liar-controls" id="liar-controls">
            <button id="btn-liar-start" class="btn-game btn-green hidden" onclick="startLiarGame()">é–‹å§‹è³­å±€</button>
            <button id="btn-liar-call" class="btn-game btn-liar-call hidden" onclick="callLiar()">LIAR!</button>
            <button id="btn-liar-play" class="btn-game btn-play hidden" onclick="playLiarCards()">å‡ºç‰Œ</button>
        </div>

        <div id="liar-reveal-overlay" class="reveal-overlay">
            <h2 style="color:white; text-shadow:0 0 20px #ef4444;">æª¢é©—ä¸­...</h2>
            <div class="reveal-stage" id="reveal-cards-container"></div>
            <div id="reveal-verdict" style="font-size:2em; font-weight:900; margin-top:20px; min-height:50px;"></div>
        </div>
        
        <div id="intro-overlay">
            <div class="intro-grid" id="intro-grid"></div>
            <div class="intro-side" id="intro-side"></div>
        </div>

        <div id="gun-anim-overlay" class="gun-overlay">
            <div class="gun-visual">ğŸ”«</div>
            <div class="bang-visual">BANG!</div>
            <div id="gun-result-text" style="color:white; font-size:1.5em; font-weight:bold; margin-top:20px; background:rgba(0,0,0,0.8); padding:15px; border-radius:10px; border:1px solid #444;"></div>
        </div>
    </div>

    <div id="uno-wrapper" class="hidden" style="position:relative;">
        <div class="uno-layout">
            <div class="uno-header">
                <div class="uno-room-info">
                    <span id="uno-room-name">Room</span> | <span id="uno-rules-display">Rules</span>
                </div>
                <div class="uno-header-btns">
                    <span id="uno-turn-status">ç­‰å¾…é–‹å§‹...</span>
                    <button class="btn-sm btn-green" style="margin-left:8px;" onclick="openUnoSettings()">âš™ï¸ è¨­å®š</button>
                </div>
            </div>
            <div class="uno-table-area">
                <div class="uno-opponents-bar" id="uno-opponents-container"></div>
                <div class="uno-direction-indicator" id="uno-dir-indicator"></div>
                <div class="uno-pile uno-deck" id="uno-deck" onclick="unoDrawCardClick()">
                    <div>UNO<br><small>æŠ½ç‰Œ</small></div>
                </div>
                <div class="uno-pile uno-discard" id="uno-discard-pile"></div>
                <div id="uno-center-message"></div>
            </div>
            <div class="uno-bottom-section">
                <div class="uno-controls" id="uno-controls-area">
                    <button id="uno-btn-start" class="btn-game btn-green hidden" onclick="unoStartGame()">é–‹å§‹éŠæˆ²</button>
                    <button id="uno-btn-pass" class="btn-game btn-secondary hidden" onclick="unoPassTurn()">æŠ½ç‰Œ</button>
                    <button id="uno-btn-play" class="btn-game btn-play hidden" onclick="unoPlaySelected()">å‡ºç‰Œ</button>
                </div>
                <div class="uno-hand-scroll" id="uno-my-hand"></div>
            </div>
        </div>
        <div id="uno-settings-modal" class="modal-overlay hidden">
            <div class="modal-box">
                <h3>âš™ï¸ UNO è¨­å®š</h3>
                <div style="text-align:left; margin-bottom:15px;">
                    <label style="color:#cbd5e1;">æ›´æ”¹æš±ç¨±</label>
                    <div style="display:flex; gap:10px; margin-top:5px;">
                        <input type="text" id="uno-setting-nickname" maxlength="10" style="flex:1;">
                        <button class="btn-sm btn-green" onclick="updateUnoNickname()">å„²å­˜</button>
                    </div>
                </div>
                <div style="text-align:left; margin-bottom:15px;">
                    <label style="color:#cbd5e1;">ç•«é¢ç¸®æ”¾ (å¡ç‰Œå¤§å°)</label>
                    <input type="range" id="uno-setting-scale" min="0.6" max="1.5" step="0.1" value="0.8" style="width:100%; accent-color:#8b5cf6;" oninput="updateUnoScale(this.value)">
                </div>
                <button class="btn-sm" style="background:#475569; color:white;" onclick="closeUnoSettings()">é—œé–‰</button>
            </div>
        </div>
        <div id="uno-draw-modal" class="modal-overlay hidden">
            <div class="modal-box">
                <h3>ä½ æŠ½åˆ°äº†</h3>
                <div id="uno-drawn-card-placeholder" style="display:flex; justify-content:center; margin:15px 0;"></div>
                <p id="uno-draw-msg" style="color:#94a3b8; font-size:0.9em;"></p>
                <div id="uno-draw-actions" style="display:flex; gap:10px; justify-content:center;"></div>
            </div>
        </div>
        <div id="uno-color-modal" class="modal-overlay hidden">
            <div class="modal-box">
                <h3>é¸æ“‡é¡è‰²</h3>
                <div class="uno-color-grid">
                    <div class="uno-color-btn uno-bg-red" onclick="unoSelectWildColor('red')"></div>
                    <div class="uno-color-btn uno-bg-blue" onclick="unoSelectWildColor('blue')"></div>
                    <div class="uno-color-btn uno-bg-green" onclick="unoSelectWildColor('green')"></div>
                    <div class="uno-color-btn uno-bg-yellow" onclick="unoSelectWildColor('yellow')"></div>
                </div>
            </div>
        </div>
        <div id="uno-shout" style="position:fixed; top:50%; left:50%; transform:translate(-50%,-50%); font-size:6em; font-weight:900; color:#fbbf24; text-shadow:4px 4px 0 #ef4444; z-index:3000; pointer-events:none; opacity:0;">UNO!</div>
    </div>

    <button id="btn-undo" class="btn-undo" onclick="undoStep()">â¬… æ‚”æ£‹ (Undo)</button>

    <div id="chat-area">
        <div style="margin-bottom: 8px; font-size: 0.9em; color: var(--text-muted);">
            æˆ‘æ˜¯: <span id="myNameDisplay" class="editable-name" onclick="editName()">ç©å®¶</span> âœ
        </div>
        <div id="chat-msgs"></div>
        <div class="chat-input-group">
            <input type="text" id="chatInput" placeholder="è¼¸å…¥è¨Šæ¯..." onkeypress="if(event.key==='Enter') sendMessage()">
            <button onclick="sendMessage()">å‚³é€</button>
        </div>
    </div>

    <div style="margin-top: 25px;">
        <button id="btn-restart-gen" style="background:transparent; color:#64748b; border:1px solid #334155; padding:8px 20px; border-radius:20px; cursor:pointer;" onclick="resetGame()">é‡ç½®éŠæˆ²</button>
    </div>
</div>

<div id="win-overlay">
    <h1 id="win-message">å‹åˆ©ï¼</h1>
    <button class="big-reset-btn" onclick="resetGame()">ğŸ”„ é‡æ–°é–‹å§‹ ğŸ”„</button>
    <button style="margin-top:25px; background:none; border:1px solid rgba(255,255,255,0.3); color:rgba(255,255,255,0.7); padding:8px 20px; border-radius:20px; cursor:pointer;" onclick="closeWinOverlay()">æš«æ™‚é—œé–‰</button>
</div>

<div id="customNameModal" class="modal-overlay hidden">
    <div class="modal-box">
        <h3 id="modalTitle">ğŸ‘‡è¼¸å…¥æš±ç¨±é–‹å§‹éŠæˆ²ï¼ğŸ‘‡</h3>
        <div class="modal-input-wrapper">
            <input type="text" id="modalNameInput" placeholder="ä½ çš„åå­—..." maxlength="10" onkeypress="if(event.key==='Enter') submitNameModal()">
        </div>
        <div class="modal-btns">
            <button class="modal-btn modal-btn-confirm" onclick="submitNameModal()">ç¢ºå®š</button>
            <button class="modal-btn modal-btn-cancel" onclick="closeNameModal()">å–æ¶ˆ</button>
        </div>
    </div>
</div>

<script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-app.js";
    import { getDatabase, ref, set, onValue, push, update, remove, onDisconnect, serverTimestamp, get, runTransaction, onChildAdded } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-database.js";

    const firebaseConfig = {
        apiKey: "AIzaSyC7PZLTTNf17cfp9gCHudWiWX8SYPSCdDI",
        authDomain: "onlineeasyraygame.firebaseapp.com",
        databaseURL: "https://onlineeasyraygame-default-rtdb.asia-southeast1.firebasedatabase.app",
        projectId: "onlineeasyraygame"
    };

    const app = initializeApp(firebaseConfig);
    const db = getDatabase(app);
    let currentRoomId = null, selectedGameType = 'ttt', roomDataCache = null;
    let currentUserKey = null;
    let isLiarGame = false; 
    
    let selectedLiarCards = []; 
    let isAnimating = false;
    let processingAction = false; 
    let chatInitTimestamp = Date.now();

    // UNO éŠæˆ²ç‹€æ…‹
    let unoSelectedIndices = [];
    let unoIsProcessing = false;
    let unoPendingDrawnCard = null;
    let unoPendingPlayCards = null;
    let unoLastHandsCount = {};
    let unoLastRenderedAction = "";
    let unoCenterMsgTimeoutId = null;
    let unoShowGameMsg = true; 

    // --- ç©å®¶åç¨±åˆå§‹åŒ– (Sequence 1~99) ---
    let myName = localStorage.getItem('playerName');

    async function initializePlayerName() {
        if (!myName) {
            const seqRef = ref(db, 'ongame_global/player_seq');
            try {
                const result = await runTransaction(seqRef, (currentSeq) => {
                    if (currentSeq === null || currentSeq >= 99) return 1;
                    return currentSeq + 1;
                });

                if (result.committed) {
                    const num = result.snapshot.val();
                    myName = `åŒ¿åç©å®¶${num}`;
                    localStorage.setItem('playerName', myName);
                } else {
                    myName = "åŒ¿åç©å®¶" + Math.floor(Math.random()*99+1); 
                }
            } catch (error) {
                console.error("Name transaction failed", error);
                myName = "åŒ¿åç©å®¶" + Math.floor(Math.random()*99+1);
            }
        }
        document.getElementById('myNameDisplay').innerText = myName;
    }

    initializePlayerName();

    // --- å…¨ç«™ç·šä¸Šäººæ•¸çµ±è¨ˆ ---
    const onlineRef = push(ref(db, 'online'));
    onDisconnect(onlineRef).remove();
    set(onlineRef, true);

    let totalOnlineCount = 0;
    onValue(ref(db, 'online'), (snapshot) => {
        const val = snapshot.val();
        totalOnlineCount = val ? Object.keys(val).length : 0;
        updateStatsUI();
    });

    // --- åˆå§‹åŒ–ï¼šé¡¯ç¤ºæ‰€æœ‰æˆ¿é–“ ---
    let totalInGameCount = 0;
    onValue(ref(db, 'ongame_room'), (snapshot) => {
        const container = document.getElementById('allRoomsContainer');
        container.innerHTML = "";
        const rooms = snapshot.val();
        totalInGameCount = 0;

        if (!rooms) { 
            container.innerHTML = "<p style='color:#94a3b8; margin-top:20px;'>ç›®å‰æ²’æœ‰æˆ¿é–“ï¼Œä¾†é–‹ä¸€å€‹å§ï¼</p>"; 
            updateStatsUI();
            return; 
        }
        
        Object.entries(rooms).reverse().forEach(([id, r]) => {
            let userCount = 0;
            if (r.users) {
                if (r.type === 'uno') userCount = Object.values(r.users).filter(u => u.online).length;
                else userCount = Object.values(r.users).filter(u => u.status !== 'offline').length;
            }
            totalInGameCount += userCount;

            let typeName = 'âŒä¸€èˆ¬åœˆå‰';
            if (r.type === 'c4') typeName = 'ğŸ”µé‡åŠ›å››é€£';
            if (r.type === 'ttt-infinite') typeName = 'â™¾ï¸ç„¡é™åœˆå‰';
            if (r.type === 'liar') typeName = 'ğŸ”«é¨™å­æ¡ŒéŠ';
            if (r.type === 'uno') typeName = 'ğŸƒ UNO';

            const hasPass = r.password && r.password !== "";
            const lockIcon = hasPass ? '<span class="lock-icon">ğŸ”’</span>' : '';
            const passwordArg = hasPass ? r.password : ""; 
            
            let statusBadge = '<span class="status-badge status-wait">ç­‰å¾…ä¸­</span>';
            if (r.status === 'playing' || (r.turn > 0 && r.type !== 'liar') || (r.type === 'uno' && r.gameState === 'playing')) {
                statusBadge = '<span class="status-badge status-play">éŠæˆ²ä¸­</span>';
            }

            let metaInfo = "";
            if (r.type === 'liar') {
                metaInfo = `äººæ•¸: ${userCount}`;
                if (r.anytimeLiar) metaInfo += ` | éš¨æ™‚æŠ“è¬ŠON`;
            } else if (r.type === 'uno') {
                metaInfo = `äººæ•¸: ${userCount}`;
                if (r.settings) metaInfo += ` | é€£å‡º:${r.settings.chain?'ON':'OFF'} ç–ŠåŠ :${r.settings.stack?'ON':'OFF'}`;
            } else {
                const rows = r.rows || 3;
                const cols = r.cols || 3;
                metaInfo = `å¤§å°: ${rows}x${cols} | äººæ•¸: ${userCount}`;
            }

            const div = document.createElement('div');
            div.className = 'room-item';
            div.innerHTML = `
                <div class="room-info">
                    <span class="room-name">${typeName} | ${r.name} ${lockIcon} ${statusBadge}</span>
                    <div class="room-meta">${metaInfo}</div>
                </div>
                <div>
                    <button class="btn-sm btn-green" onclick="attemptJoin('${id}', '${passwordArg}')">åŠ å…¥</button>
                    <button class="btn-sm btn-red" onclick="deleteRoom('${id}')">åˆªé™¤</button>
                </div>`;
            container.appendChild(div);
        });
        updateStatsUI();
    });

    function updateStatsUI() {
        const lobbyCount = Math.max(0, totalOnlineCount - totalInGameCount);
        document.getElementById('inGameCount').innerText = totalInGameCount;
        document.getElementById('lobbyCount').innerText = lobbyCount;
    }

    window.attemptJoin = async (id, correctPass) => {
        if (correctPass && correctPass !== "undefined" && correctPass !== "") {
            const input = prompt("æ­¤æˆ¿é–“æœ‰å¯†ç¢¼ï¼Œè«‹è¼¸å…¥ï¼š");
            if (input !== correctPass) { alert("å¯†ç¢¼éŒ¯èª¤ï¼"); return; }
        }

        const roomSnapshot = await get(ref(db, `ongame_room/${id}`));
        const roomData = roomSnapshot.val();
        
        if (roomData && roomData.type === 'liar') {
            handleLiarJoin(id, roomData);
        } else if (roomData && roomData.type === 'uno') {
            handleUnoJoin(id, roomData);
        } else {
            enterRoom(id);
        }
    };

    let pendingRoomId = null;
    let pendingRoomData = null;

    window.handleLiarJoin = (id, roomData) => {
        pendingRoomId = id;
        pendingRoomData = roomData;
        document.getElementById('modalNameInput').value = myName;
        document.getElementById('modalTitle').innerText = "ğŸ‘‡è¼¸å…¥æš±ç¨±é–‹å§‹éŠæˆ²ï¼ğŸ‘‡";
        document.getElementById('customNameModal').classList.remove('hidden');
        document.getElementById('modalNameInput').focus();
    };

    window.handleUnoJoin = (id, roomData) => {
        pendingRoomId = id;
        pendingRoomData = roomData;
        document.getElementById('modalNameInput').value = myName;
        document.getElementById('modalTitle').innerText = "ğŸ‘‡è¼¸å…¥æš±ç¨±é€²å…¥ UNO æˆ¿é–“ğŸ‘‡";
        document.getElementById('customNameModal').classList.remove('hidden');
        document.getElementById('modalNameInput').focus();
    };

    window.closeNameModal = () => {
        document.getElementById('customNameModal').classList.add('hidden');
        pendingRoomId = null;
        pendingRoomData = null;
    };

    window.submitNameModal = () => {
        let inputName = document.getElementById('modalNameInput').value;
        if (!inputName || inputName.trim() === "") return;
        inputName = inputName.trim();

        const users = pendingRoomData.users || {};
        let existingKey = null;
        let isOnline = false;

        for (const [key, user] of Object.entries(users)) {
            if (user.name === inputName) {
                existingKey = key;
                if (pendingRoomData.type === 'uno') {
                    if (user.online) isOnline = true;
                } else {
                    if (user.status !== 'offline') isOnline = true;
                }
                break;
            }
        }

        if (existingKey && isOnline) {
            const title = document.getElementById('modalTitle');
            title.innerText = "ç—¾ã„›..å¥½åƒæœ‰é‡è¤‡çš„åå­— è«‹é‡æ–°è¼¸å…¥:>";
            const box = document.querySelector('.modal-box');
            box.classList.remove('shaking');
            void box.offsetWidth; 
            box.classList.add('shaking');
            return; 
        }

        const targetRoomId = pendingRoomId;
        closeNameModal();

        if (existingKey) {
            myName = inputName;
            localStorage.setItem('playerName', myName);
            enterRoom(targetRoomId, existingKey);
        } else {
            myName = inputName;
            localStorage.setItem('playerName', myName);
            enterRoom(targetRoomId, null);
        }
    };

    window.showCreateRoom = (type) => {
        selectedGameType = type;
        const btnInfinite = document.getElementById('btn-infinite');
        const btnConfirm = document.getElementById('btn-confirm');
        const normalSettings = document.getElementById('normalSettings');
        const liarSettings = document.getElementById('liarSettings');
        const unoSettings = document.getElementById('unoSettings');
        
        let title = "å‰µç«‹æˆ¿é–“";
        document.getElementById('createTitle').innerText = title;

        btnInfinite.classList.add('hidden');
        normalSettings.classList.remove('hidden');
        liarSettings.classList.add('hidden');
        if (unoSettings) unoSettings.classList.add('hidden');
        
        if (type === 'liar') {
            document.getElementById('createTitle').innerText = "å‰µç«‹ é¨™å­æ¡ŒéŠ (Liar's Deck)";
            normalSettings.classList.add('hidden');
            liarSettings.classList.remove('hidden');
            btnConfirm.innerText = "å‰µç«‹ è³­å±€";
            btnConfirm.onclick = createRoom;
        } else if (type === 'uno') {
            document.getElementById('createTitle').innerText = "å‰µç«‹ UNO æˆ¿é–“";
            normalSettings.classList.add('hidden');
            if (unoSettings) unoSettings.classList.remove('hidden');
            btnConfirm.innerText = "å‰µç«‹ UNO æˆ¿é–“";
            btnConfirm.onclick = createRoom;
        } else if (type === 'c4') {
            document.getElementById('createTitle').innerText = 'å‰µç«‹ å››é€£æ£‹';
            document.getElementById('inputRows').value = 6;
            document.getElementById('inputCols').value = 7;
            document.getElementById('inputWin').value = 4;
            btnConfirm.innerText = "ç¢ºèªå‰µç«‹";
            btnConfirm.onclick = createRoom;
        } else {
            document.getElementById('createTitle').innerText = 'å‰µç«‹ æ£‹ç›¤é€£ç·š';
            document.getElementById('inputRows').value = 3;
            document.getElementById('inputCols').value = 3;
            document.getElementById('inputWin').value = 3;
            btnInfinite.classList.remove('hidden');
            btnConfirm.innerText = "å‰µç«‹ ä¸€èˆ¬åœˆåœˆå‰å‰";
            btnConfirm.onclick = () => { selectedGameType = 'ttt'; createRoom(); };
        }
        showSection('createRoomSection');
    };

    window.createInfiniteRoom = () => { selectedGameType = 'ttt-infinite'; createRoom(); };

    window.createRoom = () => {
        const name = document.getElementById('roomName').value || "å¥½ç©æˆ¿é–“";
        const pass = document.getElementById('roomPass').value;
        const roomRef = push(ref(db, 'ongame_room'));
        
        let roomData = { name, password: pass, type: selectedGameType, users: {}, status: 'waiting', chat: {} };

        if (selectedGameType === 'liar') {
            const anytimeLiar = document.getElementById('checkAnytimeLiar').checked;
            roomData = { 
                ...roomData, 
                gameState: 'waiting', 
                deck: [], 
                stack: [], 
                hands: {}, 
                guns: {},
                anytimeLiar: anytimeLiar 
            };
        } else if (selectedGameType === 'uno') {
            const chain = document.getElementById('uno-rule-chain') && document.getElementById('uno-rule-chain').checked;
            const stack = document.getElementById('uno-rule-stack') && document.getElementById('uno-rule-stack').checked;
            const initialHandSize = parseInt((document.getElementById('uno-initialHandSize') && document.getElementById('uno-initialHandSize').value) || 7) || 7;
            roomData = {
                ...roomData,
                type: 'uno',
                gameState: 'waiting',
                settings: { chain: !!chain, stack: !!stack },
                initialHandSize,
                users: {},
                turnIndex: 0,
                direction: 1,
                accumulatedDraw: 0,
                currentColor: 'red',
                deck: [],
                discardPile: [],
                lastAction: ''
            };
        } else {
            let rows = parseInt(document.getElementById('inputRows').value) || 3;
            let cols = parseInt(document.getElementById('inputCols').value) || 3;
            let win = parseInt(document.getElementById('inputWin').value) || 3;
            if(rows < 3) rows = 3; if(cols < 3) cols = 3; if(win < 3) win = 3;
            
            const initBoard = selectedGameType === 'c4' ? Array(rows * cols).fill(0) : Array(rows * cols).fill("");
            
            roomData = {
                ...roomData,
                board: initBoard, turn: 0, 
                rows: rows, cols: cols, winCondition: win,
                history: selectedGameType === 'ttt-infinite' ? [{board:initBoard, moves:[]}] : [initBoard],
                moves: selectedGameType === 'ttt-infinite' ? [] : null
            };
        }

        set(roomRef, roomData).then(() => {
            if (selectedGameType === 'liar') {
                handleLiarJoin(roomRef.key, roomData);
            } else if (selectedGameType === 'uno') {
                handleUnoJoin(roomRef.key, roomData);
            } else {
                enterRoom(roomRef.key);
            }
        });
    };

    window.enterRoom = (id, reconnectKey = null) => {
        currentRoomId = id;
        showSection('gameArea');
        document.getElementById('myNameDisplay').innerText = myName;
        chatInitTimestamp = Date.now(); 

        let userRef;
        if (reconnectKey) {
            userRef = ref(db, `ongame_room/${id}/users/${reconnectKey}`);
            currentUserKey = reconnectKey;
        } else {
            userRef = push(ref(db, `ongame_room/${id}/users`));
            currentUserKey = userRef.key;
        }

        get(ref(db, `ongame_room/${id}/type`)).then((snap) => {
            const type = snap.val();
            isLiarGame = (type === 'liar');
            const isUnoGame = (type === 'uno');
            
            if (isUnoGame) {
                update(userRef, { name: myName, online: true });
                onDisconnect(userRef).update({ online: false });
            } else if (isLiarGame) {
                update(userRef, { name: myName, status: 'online' });
                onDisconnect(userRef).update({ status: 'offline' });
            } else {
                update(userRef, { name: myName, status: 'online' });
                onDisconnect(userRef).remove();
            }
        });

        onValue(ref(db, 'ongame_room/' + id), (snapshot) => {
            const data = snapshot.val();
            if (!data) { alert("æˆ¿é–“å·²è¢«åˆªé™¤æˆ–ä¸å­˜åœ¨"); leaveRoom(); return; }
            roomDataCache = data;
            
            if (isAnimating && data.type === 'liar') {
                if (data.gameState === 'challenge') {
                } else if (data.gameState === 'playing' || data.gameState === 'ended') {
                } else {
                   return; 
                }
            }
            
            if (data.type === 'liar') {
                renderLiarGame(data);
            } else if (data.type === 'uno') {
                renderUnoGame(data);
            } else {
                renderBoardGame(data);
            }
        });

        onValue(ref(db, `ongame_room/${id}/chat`), (snapshot) => {
            const chatDiv = document.getElementById('chat-msgs');
            chatDiv.innerHTML = "";
            const msgs = snapshot.val();
            if(msgs) {
                Object.values(msgs).forEach(m => {
                    const p = document.createElement('div');
                    p.innerHTML = `<b>${m.user}:</b> ${m.text}`;
                    chatDiv.appendChild(p);
                });
                chatDiv.scrollTop = chatDiv.scrollHeight;
            }
        });

        onChildAdded(ref(db, `ongame_room/${id}/chat`), (data) => {
            const msg = data.val();
            if (msg.time > chatInitTimestamp) {
                spawnFloatingMsg(msg.text);
            }
        });
    };
    
    function spawnFloatingMsg(text) {
        const zone = document.getElementById('floating-chat-zone');
        const el = document.createElement('div');
        el.className = 'float-msg';
        el.innerText = text;
        el.style.left = (30 + Math.random() * 40) + '%'; 
        zone.appendChild(el);
        setTimeout(() => el.remove(), 3000);
    }

    // --- UNO éŠæˆ²æ¸²æŸ“èˆ‡é‚è¼¯ ---
    function renderUnoGame(data) {
        document.getElementById('ttt-board').classList.add('hidden');
        document.getElementById('c4-game-wrapper').classList.add('hidden');
        document.getElementById('liar-wrapper').classList.add('hidden');
        document.getElementById('btn-undo').classList.add('hidden');
        document.getElementById('btn-restart-gen').classList.add('hidden');
        document.getElementById('status').classList.add('hidden');
        document.getElementById('uno-wrapper').classList.remove('hidden');

        document.getElementById('roomDisplayInfo').innerText = data.name;
        document.getElementById('uno-room-name').innerText = data.name;
        document.getElementById('uno-rules-display').innerText = `é€£å‡º:${(data.settings&&data.settings.chain)?'ON':'OFF'} | ç–ŠåŠ :${(data.settings&&data.settings.stack)?'ON':'OFF'}`;

        const users = Object.keys(data.users || {});
        const order = data.playerOrder || users;
        const currentTurnUser = order[data.turnIndex];
        const isMyTurn = (currentTurnUser === currentUserKey);

        // é‡ç½®é¸å–ç‹€æ…‹ (è‹¥éè‡ªå·±çš„å›åˆã€æˆ–è€…éŠæˆ²æœªåœ¨é€²è¡Œä¸­ï¼Œå‰‡å°‡é¸å–çš„ç‰Œé™ä¸‹æ­¸ä½)
        if ((!isMyTurn || data.gameState !== 'playing') && unoSelectedIndices.length > 0) {
            unoSelectedIndices = [];
        }

        if (data.hands) {
            Object.entries(data.hands).forEach(([uid, hand]) => {
                const count = Array.isArray(hand) ? hand.length : 0;
                const prev = unoLastHandsCount[uid];
                if (count === 1 && prev !== 1) showUnoAnim();
                unoLastHandsCount[uid] = count;
            });
            Object.keys(unoLastHandsCount).forEach((uid) => {
                if (!data.hands[uid]) delete unoLastHandsCount[uid];
            });
        }

        const statusEl = document.getElementById('uno-turn-status');
        if (data.gameState === 'waiting') {
            statusEl.innerText = `ç­‰å¾…ä¸­ (${users.length}äºº)`;
            document.getElementById('uno-btn-start').classList.toggle('hidden', users.length < 2);
            document.getElementById('uno-btn-play').classList.add('hidden');
            document.getElementById('uno-btn-pass').classList.add('hidden');
        } else if (data.gameState === 'playing') {
            document.getElementById('uno-btn-start').classList.add('hidden');
            if (isMyTurn) {
                statusEl.innerText = "ğŸ‘‰ è¼ªåˆ°ä½ äº†ï¼";
                statusEl.style.color = "#facc15";
            } else {
                const name = data.users[currentTurnUser]?.name || "å°æ‰‹";
                statusEl.innerText = `ç­‰å¾… ${name}...`;
                statusEl.style.color = "#cbd5e1";
            }
            const btnPlay = document.getElementById('uno-btn-play');
            const btnPass = document.getElementById('uno-btn-pass');
            if (isMyTurn) {
                btnPlay.classList.toggle('hidden', unoSelectedIndices.length === 0);
                btnPass.classList.toggle('hidden', false);
                btnPass.innerText = (data.accumulatedDraw > 0) ? `ç½°æŠ½ (${data.accumulatedDraw})` : "æŠ½ç‰Œ";
            } else {
                btnPlay.classList.add('hidden');
                btnPass.classList.add('hidden');
            }
        } else if (data.gameState === 'ended') {
            const winner = data.users[data.winner]?.name;
            statusEl.innerText = `ğŸ† è´å®¶: ${winner}`;
            setTimeout(() => { if (confirm("é‡æ–°é–‹å§‹?")) unoResetGame(); }, 1500);
        }

        const centerMsgEl = document.getElementById('uno-center-message');
        const currentAction = data.lastAction || "";
        if (currentAction && unoShowGameMsg) {
            if (currentAction !== unoLastRenderedAction) {
                centerMsgEl.innerHTML = currentAction;
                centerMsgEl.style.opacity = "1";
                if (unoCenterMsgTimeoutId) clearTimeout(unoCenterMsgTimeoutId);
                unoCenterMsgTimeoutId = setTimeout(() => { centerMsgEl.style.opacity = "0"; }, 3000);
                unoLastRenderedAction = currentAction;
            }
        } else {
            centerMsgEl.style.opacity = "0";
            if (unoCenterMsgTimeoutId) { clearTimeout(unoCenterMsgTimeoutId); unoCenterMsgTimeoutId = null; }
            unoLastRenderedAction = "";
        }

        const oppContainer = document.getElementById('uno-opponents-container');
        oppContainer.innerHTML = "";
        order.forEach((uid, idx) => {
            if (uid === currentUserKey) return;
            const u = data.users[uid];
            const handCount = (data.hands && data.hands[uid]) ? data.hands[uid].length : 0;
            const isActive = (data.gameState === 'playing' && idx === data.turnIndex);
            const isOffline = !u.online;
            const div = document.createElement('div');
            div.className = `uno-opponent-card ${isActive ? 'active' : ''}`;
            div.innerHTML = `<div class="opp-name">${isOffline ? u.name + ' (é›¢ç·š)' : u.name}</div><div class="opp-count">${handCount}</div><small style="font-size:0.6rem; color:#94a3b8;">cards</small>`;
            oppContainer.appendChild(div);
        });

        const discardEl = document.getElementById('uno-discard-pile');
        discardEl.innerHTML = "";
        if (data.discardPile && data.discardPile.length > 0) {
            const total = data.discardPile.length;
            const startIdx = Math.max(0, total - 5);
            const recentCards = data.discardPile.slice(startIdx);
            recentCards.forEach((card, idx) => {
                let visualCard = { ...card };
                const isTop = (idx === recentCards.length - 1);
                let extraClass = "";
                if (isTop && card.color === 'black') {
                    if (data.currentColor === 'red') extraClass = "uno-tint-red";
                    else if (data.currentColor === 'blue') extraClass = "uno-tint-blue";
                    else if (data.currentColor === 'green') extraClass = "uno-tint-green";
                    else if (data.currentColor === 'yellow') extraClass = "uno-tint-yellow";
                }
                const cardDom = createUnoCardDOM(visualCard);
                if (extraClass) cardDom.classList.add(extraClass);
                cardDom.style.position = "absolute";
                const offset = idx * 3;
                cardDom.style.top = (-offset) + "px";
                cardDom.style.left = (offset) + "px";
                cardDom.style.transform = "rotate(" + (card.rotation || (Math.random()*20-10)) + "deg)";
                cardDom.style.zIndex = String(idx);
                discardEl.appendChild(cardDom);
            });
        }

        const dirEl = document.getElementById('uno-dir-indicator');
        if (dirEl) dirEl.style.animationDirection = (data.direction === 1) ? 'normal' : 'reverse';

        renderUnoHand(data);
    }

    function renderUnoHand(data) {
        const container = document.getElementById('uno-my-hand');
        container.innerHTML = "";
        const myHand = (data.hands && data.hands[currentUserKey]) || [];
        if (myHand.length === 0) return;
        const overlapMargin = -28;
        myHand.forEach((c, idx) => {
            const el = createUnoCardDOM(c);
            el.style.marginLeft = (idx === 0) ? '0' : (overlapMargin + 'px');
            el.style.zIndex = idx;
            if (data.gameState === 'playing' && data.playerOrder[data.turnIndex] === currentUserKey) {
                el.onclick = () => unoToggleSelect(idx, c);
            } else el.classList.add('disabled');
            if (unoSelectedIndices.includes(idx)) el.classList.add('selected');
            container.appendChild(el);
        });
    }

    function createUnoCardDOM(card) {
        let symbol = card.value;
        if (card.type === 'skip') symbol = 'âŠ˜';
        if (card.type === 'reverse') symbol = 'â‡„';
        if (card.type === 'draw2') symbol = '+2';
        if (card.type === 'wild') symbol = 'âŠ•';
        if (card.type === 'wild4') symbol = '+4';
        let bgClass = 'uno-bg-' + card.color;
        if ((card.type === 'wild' || card.type === 'wild4') && card.color === 'black') bgClass = 'uno-bg-wild';
        const el = document.createElement('div');
        el.className = `uno-card ${bgClass}`;
        el.innerHTML = `<div class="corner tl">${symbol}</div><div class="card-oval"><span class="card-symbol">${symbol}</span></div><div class="corner br">${symbol}</div>`;
        return el;
    }

    function getUnoSortWeight(card) {
        const colorWeight = { red: 1000, blue: 2000, green: 3000, yellow: 4000, black: 5000 };
        const typeWeight = { '0':0,'1':1,'2':2,'3':3,'4':4,'5':5,'6':6,'7':7,'8':8,'9':9,'skip':20,'reverse':21,'draw2':22,'wild':50,'wild4':51 };
        return (colorWeight[card.color] || 0) + (typeWeight[card.value] || 0);
    }
    function sortUnoHandArray(hand) { return hand.sort((a, b) => getUnoSortWeight(a) - getUnoSortWeight(b)); }

    window.unoToggleSelect = (idx, card) => {
        if (unoIsProcessing) return;
        const data = roomDataCache;
        if (!data || !data.settings) return;
        if (!data.settings.chain) unoSelectedIndices = [idx];
        else {
            if (unoSelectedIndices.includes(idx)) unoSelectedIndices = unoSelectedIndices.filter(i => i !== idx);
            else {
                if (unoSelectedIndices.length > 0) {
                    const firstCard = data.hands[currentUserKey][unoSelectedIndices[0]];
                    if (card.value === firstCard.value) unoSelectedIndices.push(idx);
                    else unoSelectedIndices = [idx];
                } else unoSelectedIndices = [idx];
            }
        }
        renderUnoGame(data);
    };

    window.unoStartGame = async () => {
        unoSelectedIndices = []; // é–‹å§‹éŠæˆ²å¼·åˆ¶æ­¸ä½
        const data = roomDataCache;
        const users = Object.keys(data.users || {});
        const deck = unoGenerateDeck();
        const hands = {};
        const handSize = data.initialHandSize || 7;
        users.forEach(u => { hands[u] = sortUnoHandArray(deck.splice(0, handSize)); });
        let firstCard = deck.pop();
        while (firstCard.type !== 'n') { deck.unshift(firstCard); firstCard = deck.pop(); }
        const firstCardWithRotation = { ...firstCard, rotation: (Math.random()*20-10).toFixed(1) };
        await update(ref(db, `ongame_room/${currentRoomId}`), {
            gameState: 'playing', deck, hands, discardPile: [firstCardWithRotation],
            playerOrder: users.sort(() => Math.random() - 0.5), turnIndex: 0, direction: 1,
            currentColor: firstCard.color, accumulatedDraw: 0, lastAction: "éŠæˆ²é–‹å§‹ï¼", status: 'playing'
        });
    };

    window.unoPlaySelected = () => {
        if (unoSelectedIndices.length === 0) return;
        const data = roomDataCache;
        const hand = data.hands[currentUserKey];
        const cardsToPlay = unoSelectedIndices.map(i => hand[i]);
        const top = data.discardPile[data.discardPile.length - 1];
        const lead = cardsToPlay[0];
        
        if (data.accumulatedDraw > 0) {
            const isValid = (top.type === 'draw2' && lead.type === 'draw2') || (top.type === 'wild4' && lead.type === 'wild4');
            if (!isValid) {
                alert("å¿…é ˆå‡ºåŒæ¨£çš„åŠ ç‰Œ(+2/+4)ä¾†ç–ŠåŠ ï¼Œæˆ–æŒ‰ç½°æŠ½");
                unoSelectedIndices = []; // ç„¡æ•ˆæ“ä½œæ­¸ä½
                renderUnoGame(roomDataCache);
                return;
            }
        } else {
            const colorMatch = (lead.color === data.currentColor);
            const valueMatch = (lead.value === top.value);
            const isWild = (lead.color === 'black');
            if (!colorMatch && !valueMatch && !isWild) {
                alert("é€™å¼µç‰Œç„¡æ³•æ‰“å‡ºï¼");
                unoSelectedIndices = []; // ç„¡æ•ˆæ“ä½œæ­¸ä½
                renderUnoGame(roomDataCache);
                return;
            }
        }
        if (cardsToPlay[cardsToPlay.length - 1].color === 'black') {
            unoPendingPlayCards = { indices: [...unoSelectedIndices], cards: cardsToPlay };
            document.getElementById('uno-color-modal').classList.remove('hidden');
            return;
        }
        executeUnoMove(unoSelectedIndices, cardsToPlay, null);
    };

    window.unoSelectWildColor = (color) => {
        document.getElementById('uno-color-modal').classList.add('hidden');
        if (unoPendingPlayCards && unoPendingPlayCards.fromDraw) {
            finishUnoPlayDrawn(unoPendingPlayCards.cards[0], color);
            unoPendingPlayCards = null;
        } else if (unoPendingPlayCards) {
            executeUnoMove(unoPendingPlayCards.indices, unoPendingPlayCards.cards, color);
            unoPendingPlayCards = null;
        }
    };

    async function executeUnoMove(indices, cards, nextColor) {
        unoIsProcessing = true;
        const data = roomDataCache;
        let newHand = [...data.hands[currentUserKey]];
        indices.forEach(i => newHand[i] = null);
        newHand = newHand.filter(c => c !== null);
        newHand = sortUnoHandArray(newHand);

        const updates = {};
        updates[`ongame_room/${currentRoomId}/hands/${currentUserKey}`] = newHand;
        let dir = data.direction, acc = data.accumulatedDraw, steps = 1, newlyAddedAcc = 0;
        let actionMsg = "";
        const myNameInGame = data.users[currentUserKey].name;

        cards.forEach(c => {
            if (c.type === 'reverse') {
                if (data.playerOrder.length === 2) steps += 1;
                else dir *= -1;
                actionMsg = `${myNameInGame} é€²è¡Œäº†è¿´è½‰ï¼`;
            }
            if (c.type === 'skip') {
                steps += 1;
                let targetIdx = (data.turnIndex + (dir * 1)) % data.playerOrder.length;
                if (targetIdx < 0) targetIdx += data.playerOrder.length;
                actionMsg = `${myNameInGame} ç¦æ­¢äº† ${data.users[data.playerOrder[targetIdx]].name}ï¼`;
            }
            if (c.type === 'draw2') {
                newlyAddedAcc += 2;
                let targetIdx = (data.turnIndex + (dir * 1)) % data.playerOrder.length;
                if (targetIdx < 0) targetIdx += data.playerOrder.length;
                actionMsg = `${myNameInGame} è®“ ${data.users[data.playerOrder[targetIdx]].name} å¤šäº† 2 å¼µç‰Œ`;
            }
            if (c.type === 'wild4') {
                newlyAddedAcc += 4;
                let targetIdx = (data.turnIndex + (dir * 1)) % data.playerOrder.length;
                if (targetIdx < 0) targetIdx += data.playerOrder.length;
                const colorMap = { red: 'ç´…è‰²', blue: 'è—è‰²', green: 'ç¶ è‰²', yellow: 'é»ƒè‰²' };
                actionMsg = `${myNameInGame} è®“ ${data.users[data.playerOrder[targetIdx]].name} å¤šäº† 4 å¼µç‰Œ ä¸¦é¸å–äº† ${colorMap[nextColor]}`;
            }
        });
        if (actionMsg) updates[`ongame_room/${currentRoomId}/lastAction`] = actionMsg;

        let nc = nextColor || cards[cards.length - 1].color;
        if (nc === 'black') nc = 'red';
        const cardsWithRotation = cards.map(card => ({ ...card, rotation: card.rotation || (Math.random()*20-10).toFixed(1) }));

        if (newlyAddedAcc > 0 && !(data.settings && data.settings.stack)) {
            let nextIdx = (data.turnIndex + (dir * steps)) % data.playerOrder.length;
            if (nextIdx < 0) nextIdx += data.playerOrder.length;
            const targetUserKey = data.playerOrder[nextIdx];
            let currentDeck = data.deck || [], currentDiscard = [...data.discardPile, ...cardsWithRotation], drawn = [];
            for (let k = 0; k < newlyAddedAcc; k++) {
                if (currentDeck.length === 0) {
                    if (currentDiscard.length <= 1) break;
                    const top = currentDiscard.pop();
                    currentDeck = currentDiscard.sort(() => Math.random() - 0.5);
                    currentDiscard = [top];
                }
                drawn.push(currentDeck.shift());
            }
            let targetHand = data.hands[targetUserKey] || [];
            updates[`ongame_room/${currentRoomId}/hands/${targetUserKey}`] = sortUnoHandArray([...targetHand, ...drawn]);
            updates[`ongame_room/${currentRoomId}/deck`] = currentDeck;
            updates[`ongame_room/${currentRoomId}/discardPile`] = currentDiscard;
            steps += 1;
            updates[`ongame_room/${currentRoomId}/accumulatedDraw`] = 0;
        } else {
            acc += newlyAddedAcc;
            updates[`ongame_room/${currentRoomId}/accumulatedDraw`] = acc;
            updates[`ongame_room/${currentRoomId}/discardPile`] = [...data.discardPile, ...cardsWithRotation];
        }

        let nextIdx = (data.turnIndex + (dir * steps)) % data.playerOrder.length;
        if (nextIdx < 0) nextIdx += data.playerOrder.length;
        updates[`ongame_room/${currentRoomId}/turnIndex`] = nextIdx;
        updates[`ongame_room/${currentRoomId}/direction`] = dir;
        updates[`ongame_room/${currentRoomId}/currentColor`] = nc;
        if (newHand.length === 0) {
            updates[`ongame_room/${currentRoomId}/gameState`] = 'ended';
            updates[`ongame_room/${currentRoomId}/winner`] = currentUserKey;
        }
        
        unoSelectedIndices = []; // å‡ºå®Œç‰Œå¼·åˆ¶æ­¸ä½ (ç§»åˆ° update ä¹‹å‰ï¼Œé˜²æ­¢ onValue æ¸²æŸ“åˆ°èˆŠçš„é¸å–ç‹€æ…‹)
        await update(ref(db), updates);
        unoIsProcessing = false;
    }

    window.unoDrawCardClick = async () => {
        if (unoIsProcessing || !roomDataCache) return;
        const data = roomDataCache;
        const isMyTurn = (data.playerOrder[data.turnIndex] === currentUserKey);
        if (isMyTurn && data.accumulatedDraw > 0) { unoPassTurn(); return; }
        if (!isMyTurn) return;
        let deck = [...(data.deck || [])], discard = [...(data.discardPile || [])];
        if (deck.length === 0) {
            if (discard.length <= 1) return alert("æ²’ç‰Œäº†ï¼");
            const top = discard.pop();
            deck = discard.sort(() => Math.random() - 0.5);
            discard = [top];
            await update(ref(db, `ongame_room/${currentRoomId}`), { discardPile: discard, deck: deck });
        }
        runTransaction(ref(db, `ongame_room/${currentRoomId}/deck`), (currentDeck) => {
            if (!currentDeck || currentDeck.length === 0) return currentDeck;
            currentDeck.shift();
            return currentDeck;
        }).then((result) => {
            if (result.committed) {
                const card = (data.deck || [])[0];
                showUnoDrawModal(card);
            }
        });
    };

    function showUnoDrawModal(card) {
        unoPendingDrawnCard = card;
        const modal = document.getElementById('uno-draw-modal');
        const content = document.getElementById('uno-drawn-card-placeholder');
        const msg = document.getElementById('uno-draw-msg');
        const actions = document.getElementById('uno-draw-actions');
        content.innerHTML = "";
        content.appendChild(createUnoCardDOM(card));
        const data = roomDataCache;
        const top = data.discardPile[data.discardPile.length - 1];
        const isWild = (card.color === 'black');
        const colorMatch = (card.color === data.currentColor);
        const valMatch = (card.value === top.value);
        const playable = (isWild || colorMatch || valMatch);
        actions.innerHTML = "";
        if (playable) {
            msg.innerText = "é€™å¼µç‰Œå¯ä»¥æ‰“å‡ºï¼";
            const btnKeep = document.createElement('button');
            btnKeep.className = "btn-sm";
            btnKeep.style.background = "#64748b";
            btnKeep.innerText = "æ”¶ä¸‹";
            btnKeep.onclick = () => unoPlayDrawnCard(false);
            const btnPlay = document.createElement('button');
            btnPlay.className = "btn-sm btn-green";
            btnPlay.innerText = "ä¸Ÿå‡º";
            btnPlay.onclick = () => unoPlayDrawnCard(true);
            actions.appendChild(btnKeep);
            actions.appendChild(btnPlay);
        } else {
            msg.innerText = " ";
            const btnKeep = document.createElement('button');
            btnKeep.className = "btn-sm";
            btnKeep.style.background = "#64748b";
            btnKeep.innerText = "æ”¶ä¸‹";
            btnKeep.onclick = () => unoPlayDrawnCard(false);
            actions.appendChild(btnKeep);
        }
        modal.classList.remove('hidden');
    }

    window.unoPlayDrawnCard = (playIt) => {
        document.getElementById('uno-draw-modal').classList.add('hidden');
        const card = unoPendingDrawnCard;
        unoPendingDrawnCard = null;
        const data = roomDataCache;
        if (playIt) {
            if (card.color === 'black') {
                unoPendingPlayCards = { indices: [], cards: [card], fromDraw: true };
                document.getElementById('uno-color-modal').classList.remove('hidden');
            } else finishUnoPlayDrawn(card, null);
        } else {
            const newHand = sortUnoHandArray([...data.hands[currentUserKey], card]);
            let nextIdx = (data.turnIndex + data.direction) % data.playerOrder.length;
            if (nextIdx < 0) nextIdx += data.playerOrder.length;
            
            unoSelectedIndices = []; // ææ—©é‡ç½®
            
            update(ref(db, `ongame_room/${currentRoomId}`), {
                [`hands/${currentUserKey}`]: newHand,
                turnIndex: nextIdx,
                lastAction: `${data.users[currentUserKey].name} æŠ½äº†ä¸€å¼µç‰Œ`
            }).then(() => { renderUnoGame(roomDataCache); });
        }
    };

    async function finishUnoPlayDrawn(card, wildColor) {
        const data = roomDataCache;
        const updates = {};
        let dir = data.direction, steps = 1, acc = data.accumulatedDraw, newlyAddedAcc = 0;
        let actionMsg = "";
        const myNameInGame = data.users[currentUserKey].name;
        if (card.type === 'reverse') { if (data.playerOrder.length === 2) steps += 1; else dir *= -1; actionMsg = `${myNameInGame} é€²è¡Œäº†è¿´è½‰ï¼`; }
        if (card.type === 'skip') { steps += 1; let ti = (data.turnIndex + dir) % data.playerOrder.length; if (ti < 0) ti += data.playerOrder.length; actionMsg = `${myNameInGame} ç¦æ­¢äº† ${data.users[data.playerOrder[ti]].name}ï¼`; }
        if (card.type === 'draw2') { newlyAddedAcc += 2; let ti = (data.turnIndex + dir) % data.playerOrder.length; if (ti < 0) ti += data.playerOrder.length; actionMsg = `${myNameInGame} è®“ ${data.users[data.playerOrder[ti]].name} å¤šäº† 2 å¼µç‰Œ`; }
        if (card.type === 'wild4') { newlyAddedAcc += 4; let ti = (data.turnIndex + dir) % data.playerOrder.length; if (ti < 0) ti += data.playerOrder.length; const colorMap = {red:'ç´…è‰²',blue:'è—è‰²',green:'ç¶ è‰²',yellow:'é»ƒè‰²'}; actionMsg = `${myNameInGame} è®“ ${data.users[data.playerOrder[ti]].name} å¤šäº† 4 å¼µç‰Œ ä¸¦é¸å–äº† ${colorMap[wildColor]}`; }
        if (!actionMsg) actionMsg = `${myNameInGame} æ‰“å‡ºäº† ${card.value}`;
        updates[`ongame_room/${currentRoomId}/lastAction`] = actionMsg;
        const cardWithRotation = { ...card, rotation: card.rotation || (Math.random()*20-10).toFixed(1) };
        if (newlyAddedAcc > 0 && !(data.settings && data.settings.stack)) {
            let nextIdx = (data.turnIndex + (dir * steps)) % data.playerOrder.length;
            if (nextIdx < 0) nextIdx += data.playerOrder.length;
            const targetUserKey = data.playerOrder[nextIdx];
            let currentDeck = data.deck || [], currentDiscard = [...data.discardPile, cardWithRotation], drawn = [];
            for (let k = 0; k < newlyAddedAcc; k++) {
                if (currentDeck.length === 0) { if (currentDiscard.length <= 1) break; const top = currentDiscard.pop(); currentDeck = currentDiscard.sort(() => Math.random() - 0.5); currentDiscard = [top]; }
                drawn.push(currentDeck.shift());
            }
            updates[`ongame_room/${currentRoomId}/hands/${targetUserKey}`] = sortUnoHandArray([...(data.hands[targetUserKey]||[]), ...drawn]);
            updates[`ongame_room/${currentRoomId}/deck`] = currentDeck;
            updates[`ongame_room/${currentRoomId}/discardPile`] = currentDiscard;
            steps += 1;
            updates[`ongame_room/${currentRoomId}/accumulatedDraw`] = 0;
        } else {
            acc += newlyAddedAcc;
            updates[`ongame_room/${currentRoomId}/accumulatedDraw`] = acc;
            updates[`ongame_room/${currentRoomId}/discardPile`] = [...data.discardPile, cardWithRotation];
        }
        let nextIdx = (data.turnIndex + (dir * steps)) % data.playerOrder.length;
        if (nextIdx < 0) nextIdx += data.playerOrder.length;
        let nc = wildColor || card.color;
        updates[`ongame_room/${currentRoomId}/turnIndex`] = nextIdx;
        updates[`ongame_room/${currentRoomId}/direction`] = dir;
        updates[`ongame_room/${currentRoomId}/currentColor`] = nc;
        
        unoSelectedIndices = []; // ææ—©é‡ç½®
        
        await update(ref(db), updates);
        renderUnoGame(roomDataCache);
    }

    window.unoPassTurn = async () => {
        const data = roomDataCache;
        const acc = data.accumulatedDraw;
        const myNameInGame = data.users[currentUserKey].name;
        if (acc > 0) {
            let deck = [...(data.deck||[])], discard = [...(data.discardPile||[])], drawn = [];
            for (let i = 0; i < acc; i++) {
                if (deck.length === 0) { if (discard.length <= 1) break; const top = discard.pop(); deck = discard.sort(() => Math.random() - 0.5); discard = [top]; }
                drawn.push(deck.shift());
            }
            const newHand = sortUnoHandArray([...data.hands[currentUserKey], ...drawn]);
            let nextIdx = (data.turnIndex + data.direction) % data.playerOrder.length;
            if (nextIdx < 0) nextIdx += data.playerOrder.length;
            
            unoSelectedIndices = []; // ææ—©é‡ç½®
            
            await update(ref(db, `ongame_room/${currentRoomId}`), {
                [`hands/${currentUserKey}`]: newHand, deck, discardPile: discard,
                accumulatedDraw: 0, turnIndex: nextIdx,
                lastAction: `${myNameInGame} ç½°æŠ½äº† ${acc} å¼µç‰Œ`
            });
            renderUnoGame(roomDataCache);
        } else unoDrawCardClick();
    };

    window.unoResetGame = () => {
        unoSelectedIndices = []; // é‡ç½®å¼·åˆ¶æ­¸ä½
        update(ref(db, `ongame_room/${currentRoomId}`), {
            gameState: 'waiting', hands: {}, discardPile: [], accumulatedDraw: 0, lastAction: "æº–å‚™é‡æ–°é–‹å§‹"
        });
    };

    function unoGenerateDeck() {
        const colors = ['red','blue','green','yellow'];
        let d = [];
        colors.forEach(c => {
            d.push({ type: 'n', color: c, value: '0' });
            for (let i = 1; i <= 9; i++) { d.push({ type: 'n', color: c, value: String(i) }); d.push({ type: 'n', color: c, value: String(i) }); }
            ['skip','reverse','draw2'].forEach(t => { d.push({ type: t, color: c, value: t }); d.push({ type: t, color: c, value: t }); });
        });
        for (let i = 0; i < 4; i++) { d.push({ type: 'wild', color: 'black', value: 'wild' }); d.push({ type: 'wild4', color: 'black', value: 'wild4' }); }
        return d.sort(() => Math.random() - 0.5);
    }

    function showUnoAnim() {
        const el = document.getElementById('uno-shout');
        if (!el) return;
        el.style.animation = 'none';
        el.offsetHeight;
        el.style.animation = 'unoShoutPop 1.5s forwards';
    }

    window.openUnoSettings = () => {
        document.getElementById('uno-setting-nickname').value = myName;
        document.getElementById('uno-settings-modal').classList.remove('hidden');
    };
    window.closeUnoSettings = () => document.getElementById('uno-settings-modal').classList.add('hidden');
    window.updateUnoNickname = async () => {
        const newName = (document.getElementById('uno-setting-nickname').value || '').trim();
        if (!newName) return alert("æš±ç¨±ä¸èƒ½ç‚ºç©ºï¼");
        myName = newName;
        localStorage.setItem('playerName', myName);
        if (currentRoomId && currentUserKey && roomDataCache && roomDataCache.type === 'uno') {
            await update(ref(db, `ongame_room/${currentRoomId}/users/${currentUserKey}`), { name: myName });
        }
        alert("æš±ç¨±å·²æ›´æ”¹ç‚º: " + myName);
    };
    window.updateUnoScale = (val) => {
        document.documentElement.style.setProperty('--uno-card-w', (70 * val) + 'px');
        document.documentElement.style.setProperty('--uno-card-h', (105 * val) + 'px');
        if (currentRoomId && roomDataCache && roomDataCache.type === 'uno') renderUnoHand(roomDataCache);
    };

    // --- æ£‹ç›¤éŠæˆ²æ¸²æŸ“ (åœˆåœˆå‰å‰/å››é€£æ£‹) ---
    function renderBoardGame(data) {
        document.getElementById('liar-wrapper').classList.add('hidden');
        document.getElementById('uno-wrapper').classList.add('hidden');
        document.getElementById('btn-undo').classList.remove('hidden');
        document.getElementById('btn-restart-gen').classList.remove('hidden');
        document.getElementById('status').classList.remove('hidden');
        
        document.getElementById('roomDisplayInfo').innerText = data.name;
        const rows = data.rows || 3;
        const cols = data.cols || 3;
        const userList = data.users ? Object.values(data.users) : [];
        const p1Name = userList[0] ? userList[0].name : "P1";
        const p2Name = userList[1] ? userList[1].name : "P2";
        const currentPlayerName = (data.turn % 2 === 0) ? p1Name : p2Name;
        
        document.getElementById('gameMetaInfo').innerText = `${data.type === 'c4'?'å››é€£æ£‹':'åœˆå‰'} | ${rows}x${cols}`;

        if (data.type === 'c4') {
            document.getElementById('ttt-board').classList.add('hidden');
            document.getElementById('c4-game-wrapper').classList.remove('hidden');
            renderC4Board(data, rows, cols);
             document.getElementById('status').innerText = `è¼ªåˆ°: ${currentPlayerName} ${data.turn%2===0?'(P1)':'(P2)'}`;
             document.getElementById('status').style.color = (data.turn%2===0) ? (data.p1Color||'#f87171') : (data.p2Color||'#facc15');
        } else {
            document.getElementById('c4-game-wrapper').classList.add('hidden');
            document.getElementById('ttt-board').classList.remove('hidden');
            renderTTTBoard(data, rows, cols);
            document.getElementById('status').innerText = `è¼ªåˆ°: ${currentPlayerName} (${data.turn%2===0?'X':'O'})`;
            document.getElementById('status').style.color = '#f87171';
        }
        checkBoardWinner(data);
    }

    // --- ç§»æ¤ç‰ˆ é¨™å­æ¡ŒéŠ é‚è¼¯èˆ‡æ¸²æŸ“ ---

    function renderLiarGame(data) {
        document.getElementById('ttt-board').classList.add('hidden');
        document.getElementById('c4-game-wrapper').classList.add('hidden');
        document.getElementById('uno-wrapper').classList.add('hidden');
        document.getElementById('btn-undo').classList.add('hidden');
        document.getElementById('btn-restart-gen').classList.add('hidden');
        document.getElementById('status').classList.add('hidden');
        document.getElementById('liar-wrapper').classList.remove('hidden');
        
        document.getElementById('roomDisplayInfo').innerText = data.name;
        document.getElementById('gameMetaInfo').innerText = "Liar's Deck" + (data.anytimeLiar ? " | éš¨æ™‚æŠ“è¬ŠON" : "");

        const users = data.users || {};
        const playerKeys = data.playerOrder || Object.keys(users);
        
        const statusEl = document.getElementById('liar-status-text');
        const targetEl = document.getElementById('liar-target-display');
        const stackArea = document.getElementById('liar-stack-area');
        const lastMoveInfoEl = document.getElementById('last-move-info');
        const myGunDiv = document.getElementById('my-gun-status');
        const introOverlay = document.getElementById('intro-overlay');
        
        if (data.gameState !== 'intro') {
            introOverlay.style.display = 'none';
        }

        if (data.gameState === 'waiting') {
            const activeCount = Object.values(users).filter(u => u.status !== 'offline').length;
            statusEl.innerText = `æº–å‚™ä¸­ (åœ¨ç·š: ${activeCount}äºº)`;
            targetEl.classList.add('hidden');
            stackArea.innerHTML = "";
            lastMoveInfoEl.innerText = ""; 
            myGunDiv.classList.add('hidden'); 
            document.getElementById('liar-reveal-overlay').style.display = 'none';
            document.getElementById('gun-anim-overlay').style.display = 'none';
            isAnimating = false;
            processingAction = false;
            
            if (playerKeys[0] === currentUserKey && activeCount >= 2) {
                document.getElementById('btn-liar-start').classList.remove('hidden');
            } else {
                document.getElementById('btn-liar-start').classList.add('hidden');
            }
        } 
        else if (data.gameState === 'intro') {
            statusEl.innerText = "ç™¼ç‰Œä¸­...";
            document.getElementById('btn-liar-start').classList.add('hidden');
            renderIntroDeck();
        }
        else if (data.gameState === 'playing') {
            document.getElementById('btn-liar-start').classList.add('hidden');
            document.getElementById('liar-reveal-overlay').style.display = 'none';
            document.getElementById('gun-anim-overlay').style.display = 'none';
            targetEl.classList.remove('hidden');
            targetEl.innerText = `ç•¶å±€ç‰Œ: ${data.targetRank}`;
            myGunDiv.classList.remove('hidden');
            
            const curPlayerKey = playerKeys[data.turnIndex];
            const curPlayer = users[curPlayerKey];
            const isMyTurn = (curPlayerKey === currentUserKey);
            
            checkLiarTurnSkip(data, curPlayerKey, curPlayer);

            const aliveKeys = playerKeys.filter(k => !data.guns[k]?.isDead);
            const lastMove = data.stack && data.stack.length > 0 ? data.stack[data.stack.length - 1] : null;
            let forceCall = false;

            const otherPlayersWithCards = aliveKeys.filter(k => k !== curPlayerKey && data.hands[k] && data.hands[k].length > 0);
            if (lastMove) {
                if (aliveKeys.length === 2) {
                    const prevOwnerHand = data.hands[lastMove.owner];
                    if (prevOwnerHand && prevOwnerHand.length === 0) {
                        forceCall = true;
                    }
                }
                if (otherPlayersWithCards.length === 0) {
                    forceCall = true;
                }
            }
            
            if (forceCall) {
                if (isMyTurn) {
                    statusEl.innerHTML = `<b style="color:#ef4444">æ²’ç‰Œäº† Liar!</b>`;
                    document.getElementById('liar-controls').classList.add('hidden');

                    if (!window.liarAutoCallPending) {
                        window.liarAutoCallPending = true;
                        setTimeout(() => {
                            callLiar();
                            window.liarAutoCallPending = false; 
                        }, 1000);
                    }
                } else {
                    statusEl.innerHTML = `ç„¡äººå¯æ¥ç‰Œ/å°æ‰‹å·²ç©ºï¼Œç³»çµ±å³å°‡å¼·åˆ¶æª¢é©—...`;
                    document.getElementById('liar-controls').classList.add('hidden');
                }
            } else {
                window.liarAutoCallPending = false; 
                document.getElementById('liar-controls').classList.remove('hidden'); 

                let playerName = curPlayer ? curPlayer.name : "æœªçŸ¥ç©å®¶";
                if (!curPlayer || curPlayer.status === 'offline') playerName += "(æ–·ç·š)";

                statusEl.innerHTML = isMyTurn ? 
                    `<b style="color:#facc15">ğŸ”´ è¼ªåˆ°ä½ äº†ï¼è«‹å‡ºç‰Œ</b>` : 
                    `ç­‰å¾… ${playerName} å‡ºç‰Œ...`;
            }

            if (!forceCall) {
                const btnCall = document.getElementById('btn-liar-call');
                const btnPlay = document.getElementById('btn-liar-play');
                
                if (!isAnimating && !processingAction) {
                    btnCall.disabled = false;
                    btnPlay.disabled = false;
                }
                
                const hasStack = (data.stack && data.stack.length > 0);
                const isAmAlive = !data.guns[currentUserKey].isDead;

                if (isMyTurn) {
                    btnPlay.classList.remove('hidden');
                } else {
                    btnPlay.classList.add('hidden');
                }

                let showCall = false;
                if (hasStack && isAmAlive) {
                    if (isMyTurn) {
                        showCall = true;
                    }
                    else if (data.anytimeLiar) {
                        const lastOwner = lastMove ? lastMove.owner : null;
                        if (currentUserKey !== lastOwner) {
                            showCall = true;
                        }
                    }
                }

                if (showCall) {
                    btnCall.classList.remove('hidden');
                    btnCall.innerText = "LIAR!";
                } else {
                    btnCall.classList.add('hidden');
                }
            }

            stackArea.innerHTML = "";
            if (data.stack) {
                data.stack.forEach((move, i) => {
                    if (i < data.stack.length - 10) return; 
                    const c = document.createElement('div');
                    c.className = 'card card-back';
                    c.style.position = 'absolute';
                    c.style.width = '40px'; c.style.height = '60px';
                    c.style.transform = `rotate(${Math.sin(i*99)*20}deg) translate(${Math.cos(i)*5}px, ${Math.sin(i)*5}px)`;
                    stackArea.appendChild(c);
                });
                if (data.lastMove) {
                    lastMoveInfoEl.innerText = `${data.lastMove.name} å‡ºäº† ${data.lastMove.count} å¼µ`;
                    lastMoveInfoEl.style.display = 'block';
                } else {
                    lastMoveInfoEl.style.display = 'none';
                }
            } else {
                lastMoveInfoEl.style.display = 'none';
            }
        }
        else if (data.gameState === 'challenge' && !isAnimating) {
             triggerChallengeAnimation(data);
        }
        else if (data.gameState === 'ended') {
            document.getElementById('win-message').innerHTML = `ğŸ† æœ€å¾Œç”Ÿé‚„è€…<br>${data.winnerName}`;
            document.getElementById('win-overlay').style.display = 'flex';
        }

        const oppRow = document.getElementById('liar-opponents');
        oppRow.innerHTML = "";
        playerKeys.forEach(k => {
            if (k === currentUserKey) return;
            const u = users[k];
            const safeName = u ? u.name : "Unknown";
            const isOffline = !u || u.status === 'offline';
            
            const handSize = data.hands && data.hands[k] ? data.hands[k].length : 0;
            const gun = data.guns ? data.guns[k] : {chamber:0, isDead:false};
            
            let statusClass = "";
            if (k === playerKeys[data.turnIndex]) statusClass = "active";
            if (gun.isDead) statusClass = "dead";
            if (!gun.isDead && handSize === 0 && data.gameState === 'playing') statusClass = "escaped"; 
            if (isOffline) statusClass += " offline";

            const div = document.createElement('div');
            div.className = `opponent ${statusClass}`;
            
            let bulletsHTML = "";
            for(let i=0; i<6; i++) {
                let bClass = (i < gun.chamber) ? "fired" : "live";
                bulletsHTML += `<div class="bullet-slot ${bClass}"></div>`;
            }

            div.innerHTML = `
                <div style="font-size:0.8em; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; color:white;">
                    ${safeName} ${isOffline ? '<span style="font-size:0.8em; color:#94a3b8;">(é›¢ç·š)</span>' : ''}
                </div>
                <div style="font-size:1.5em; margin:5px 0;">ğŸƒ ${handSize}</div>
                <div class="cylinder-display">${bulletsHTML}</div>
                ${gun.isDead ? '<span style="position:absolute; top:30%; left:25%; font-size:2em;">ğŸ’€</span>' : ''}
                ${statusClass.includes('escaped') ? '<span style="position:absolute; top:30%; left:20%; font-size:1.5em; color:#10b981; font-weight:bold;">SAFE</span>' : ''}
            `;
            oppRow.appendChild(div);
        });
        
        const myGunInfo = data.guns ? data.guns[currentUserKey] : {chamber:0, isDead:false};
        if (myGunDiv && data.gameState !== 'waiting') {
            let bulletsHTML = "";
            for(let i=0; i<6; i++) {
                let bClass = (i < myGunInfo.chamber) ? "fired" : "live";
                bulletsHTML += `<div class="bullet-slot ${bClass}"></div>`;
            }
            myGunDiv.innerHTML = `
                <div style="font-size:0.8em; margin-bottom:5px;">æˆ‘çš„å·¦è¼ª</div>
                <div class="cylinder-display">${bulletsHTML}</div>
                <div style="font-size:0.7em; margin-top:3px; color:#94a3b8;">
                    ${myGunInfo.isDead ? 'å·²æ­»äº¡' : `å‰©é¤˜æ©Ÿç‡: 1/${6 - myGunInfo.chamber}`}
                </div>
            `;
            if (myGunInfo.isDead) myGunDiv.style.borderColor = "red";
            else myGunDiv.style.borderColor = "#4b5563";
        }


        const myHandDiv = document.getElementById('liar-my-hand');
        const myCards = (data.hands && data.hands[currentUserKey]) || [];
        myHandDiv.innerHTML = "";
        
        if (selectedLiarCards.some(idx => idx >= myCards.length)) selectedLiarCards = [];

        myCards.forEach((c, i) => {
            const div = document.createElement('div');
            div.className = `card ${['â™¥','â™¦'].includes(c.suit)?'red':'black'} ${c.rank==='Joker'?'joker':''}`;
            if (selectedLiarCards.includes(i)) div.classList.add('selected');
            
            if (c.rank === 'Joker') div.innerHTML = 'ğŸ¤¡<br>Joker';
            else div.innerHTML = `${c.suit}<br>${c.rank}`;
            
            div.onclick = () => {
                if (data.gameState !== 'playing') return;
                if (isAnimating || processingAction) return;
                if (statusEl.innerHTML.includes("å¼·åˆ¶") || window.liarAutoCallPending || statusEl.innerHTML.includes("Liar!")) return; 
                
                const idx = selectedLiarCards.indexOf(i);
                if (idx >= 0) {
                    selectedLiarCards.splice(idx, 1);
                    div.classList.remove('selected');
                } else {
                    if (selectedLiarCards.length >= 3) return alert("æœ€å¤šå‡º3å¼µ");
                    selectedLiarCards.push(i);
                    div.classList.add('selected');
                }
            };
            myHandDiv.appendChild(div);
        });
        
        const myGun = data.guns && data.guns[currentUserKey];
        if (myGun && myGun.isDead) {
             statusEl.innerHTML = "<b style='color:red'>ğŸ’€ ä½ å·²æ­»äº¡</b>";
             document.getElementById('liar-controls').classList.add('hidden');
        }
    }

    function checkLiarTurnSkip(data, curPlayerKey, curPlayer) {
        const myGun = data.guns && data.guns[currentUserKey];
        if (!myGun || myGun.isDead) return;

        const isCurrentInvalid = !curPlayer || curPlayer.status === 'offline';
        const isCurrentDead = data.guns && data.guns[curPlayerKey] && data.guns[curPlayerKey].isDead;

        if (isCurrentInvalid || isCurrentDead) {
            console.log("åµæ¸¬åˆ°ç„¡æ•ˆ/é›¢ç·š/æ­»äº¡ç©å®¶ï¼Œæº–å‚™è·³éå›åˆ:", curPlayerKey);
            
            const players = data.playerOrder;
            let myIdx = players.indexOf(currentUserKey);
            let targetIdx = data.turnIndex;
            
            let foundNext = false;
            let nextValidIdx = targetIdx;
            let loopCount = 0;
            
            while(loopCount < players.length) {
                nextValidIdx = (nextValidIdx + 1) % players.length;
                const pk = players[nextValidIdx];
                const pu = data.users[pk];
                const pg = data.guns[pk];
                
                if (pu && pu.status !== 'offline' && !pg.isDead) {
                    foundNext = true;
                    break;
                }
                loopCount++;
            }

            if (foundNext && nextValidIdx === myIdx) {
                 update(ref(db, `ongame_room/${currentRoomId}`), {
                    turnIndex: nextValidIdx
                });
            }
        }
    }

    function renderIntroDeck() {
        const overlay = document.getElementById('intro-overlay');
        const grid = document.getElementById('intro-grid');
        const side = document.getElementById('intro-side');
        overlay.style.display = 'flex';
        grid.innerHTML = "";
        side.innerHTML = "";

        let suitCount = 6;
        let jokerCount = 2;
        if (roomDataCache && roomDataCache.deckMeta) {
            suitCount = roomDataCache.deckMeta.suitCount;
            jokerCount = roomDataCache.deckMeta.jokerCount;
        }

        grid.style.gridTemplateColumns = `repeat(${suitCount}, 1fr)`;

        const baseSuits = ['â™ ', 'â™¥', 'â™¦', 'â™£'];
        
        ['A', 'Q', 'K'].forEach((rank, rIdx) => {
            for(let i = 0; i < suitCount; i++) {
                const suit = baseSuits[i % 4];
                const div = document.createElement('div');
                div.className = `intro-card-sm ${['â™¥','â™¦'].includes(suit)?'red':'black'}`;
                div.innerText = suit + rank;
                div.style.animationDelay = (i * 0.05 + rIdx * 0.3) + 's';
                grid.appendChild(div);
            }
        });

        for(let i = 0; i < jokerCount; i++) {
            const div = document.createElement('div');
            div.className = 'intro-card-sm joker';
            div.innerText = 'JK';
            div.style.color = '#8e44ad';
            div.style.animationDelay = (1 + i * 0.2) + 's';
            side.appendChild(div);
        }
    }

    async function triggerChallengeAnimation(data) {
        if (isAnimating) return;
        isAnimating = true; 

        const res = data.challengeResult;
        const overlay = document.getElementById('liar-reveal-overlay');
        const container = document.getElementById('reveal-cards-container');
        const verdict = document.getElementById('reveal-verdict');
        
        overlay.style.display = 'flex';
        container.innerHTML = "";
        verdict.innerHTML = "";
        
        res.cards.forEach((c, i) => {
            const wrapper = document.createElement('div');
            wrapper.className = 'reveal-card-wrapper';
            wrapper.innerHTML = `
                <div class="reveal-back"></div>
                <div class="reveal-face ${['â™¥','â™¦'].includes(c.suit)?'red':'black'}">
                    ${c.rank==='Joker'?'ğŸ¤¡': c.suit + c.rank}
                </div>
            `;
            container.appendChild(wrapper);
        });

        await new Promise(r => setTimeout(r, 500));
        const cards = container.children;
        
        for (let i = 0; i < cards.length; i++) {
            cards[i].classList.add('flipped');
            const cData = res.cards[i];
            const isMatch = (cData.rank === data.targetRank || cData.rank === 'Joker');
            
            await new Promise(r => setTimeout(r, 600));
            const face = cards[i].querySelector('.reveal-face');
            if (isMatch) {
                face.classList.add('correct');
            } else {
                face.classList.add('wrong');
            }
            await new Promise(r => setTimeout(r, 400));
        }

        verdict.innerHTML = res.isLiar 
            ? `<span style="color:#ef4444">æŠ“åˆ°äº†ï¼èªªè¬Šï¼</span><br><span style="font-size:0.5em">è¼¸å®¶: ${res.loserName}</span>` 
            : `<span style="color:#10b981">èª å¯¦ï¼æŠ“éŒ¯äº†ï¼</span><br><span style="font-size:0.5em">è¼¸å®¶: ${res.loserName}</span>`;
        
        await new Promise(r => setTimeout(r, 1500));

        overlay.style.display = 'none';
        await triggerGunAnimation(res.loser, res.loserName);
    }

    async function triggerGunAnimation(loserId, loserName) {
        const overlay = document.getElementById('gun-anim-overlay');
        const txt = document.getElementById('gun-result-text');
        const bang = overlay.querySelector('.bang-visual');
        
        overlay.style.display = 'flex';
        txt.innerText = `${loserName} æ¥å—åˆ¶è£...`;
        bang.style.opacity = 0;
        bang.classList.remove('bang-animate');

        await new Promise(r => setTimeout(r, 1500)); 
        
        overlay.classList.add('shaking');
        bang.classList.add('bang-animate');
        
        const roomSnapshot = await get(ref(db, `ongame_room/${currentRoomId}`));
        const rData = roomSnapshot.val();
        const playerGun = rData.guns[loserId];
        
        await new Promise(r => setTimeout(r, 500));
        overlay.classList.remove('shaking');
        
        if (playerGun.isDead) {
            txt.innerHTML = `<span style="color:red; font-size:1.5em;">ğŸ’€ æ­»äº¡ ğŸ’€</span>`;
        } else {
            txt.innerHTML = `<span style="color:#10b981">æ­å–œå€–å­˜ğŸ˜(ç©ºåŒ…å½ˆ)</span><br>å‰©é¤˜: ${6 - playerGun.chamber}ç™¼`;
        }

        await new Promise(r => setTimeout(r, 2000));
        overlay.style.display = 'none';
        
        const players = rData.playerOrder;
        if (players[0] === currentUserKey) {
            nextLiarRound(rData);
        }
        
        isAnimating = false; 
        processingAction = false; 
    }

    window.startLiarGame = () => {
        if (isAnimating || processingAction) return; 

        const users = roomDataCache.users || {};
        const activePlayers = Object.entries(users)
            .filter(([k, u]) => u.status !== 'offline')
            .map(([k, u]) => k);
            
        const playerCount = activePlayers.length;
        if (playerCount < 2) {
             alert("äººæ•¸ä¸è¶³ï¼Œè‡³å°‘éœ€è¦2ä½åœ¨ç·šç©å®¶");
             return;
        }
        
        let suitCount = 6; 
        let jokerCount = 2;

        if (playerCount >= 5) {
            suitCount = 8;
            jokerCount = 4;
            
            while ((suitCount * 3 + jokerCount) < (playerCount * 5)) {
                suitCount++;
                if (suitCount % 2 === 0) jokerCount++;
            }
        }

        const ranks = ['A', 'Q', 'K'];
        const baseSuits = ['â™ ', 'â™¥', 'â™¦', 'â™£'];
        
        let deck = [];
        
        ranks.forEach(r => {
            for (let i = 0; i < suitCount; i++) {
                deck.push({suit: baseSuits[i % 4], rank: r});
            }
        });
        
        for (let i = 0; i < jokerCount; i++) {
            deck.push({suit: '', rank: 'Joker'});
        }

        deck.sort(() => Math.random() - 0.5);

        const hands = {};
        activePlayers.forEach(p => {
            if (deck.length >= 5) {
                hands[p] = deck.splice(0, 5);
            } else {
                hands[p] = deck.splice(0, deck.length); 
            }
        });
        
        const guns = {};
        activePlayers.forEach(p => guns[p] = { chamber: 0, bulletPos: Math.floor(Math.random()*6), isDead: false });

        update(ref(db, `ongame_room/${currentRoomId}`), {
            gameState: 'intro',
            status: 'playing', 
            playerOrder: activePlayers,
            deckMeta: { suitCount, jokerCount }
        });

        setTimeout(() => {
            update(ref(db, `ongame_room/${currentRoomId}`), {
                gameState: 'playing', deck, hands, guns, stack: [],
                turnIndex: 0, targetRank: ranks[Math.floor(Math.random()*3)],
                challengeResult: null
            });
        }, 3500);
    };

    window.playLiarCards = () => {
        if (isAnimating || processingAction) return; 
        if (!selectedLiarCards.length) return alert("è«‹é¸ç‰Œ");
        
        const myHand = roomDataCache.hands[currentUserKey];
        const played = selectedLiarCards.map(i => myHand[i]);
        const newHand = myHand.filter((_, i) => !selectedLiarCards.includes(i));
        
        const stack = roomDataCache.stack || [];
        stack.push({ cards: played, owner: currentUserKey, name: myName, count: played.length });
        
        const players = roomDataCache.playerOrder;
        
        let nextIdx = roomDataCache.turnIndex;
        let found = false;
        let loopCount = 0;
        
        const aliveCount = players.filter(p => !roomDataCache.guns[p].isDead).length;

        while (loopCount < players.length) {
            nextIdx = (nextIdx + 1) % players.length;
            const pId = players[nextIdx];
            const gun = roomDataCache.guns[pId];
            const pHand = roomDataCache.hands[pId] || []; 
            const pUser = roomDataCache.users[pId];

            if (!pUser || pUser.status === 'offline') {
                loopCount++;
                continue;
            }
            
            if (gun.isDead) {
                loopCount++;
                continue;
            }

            if (aliveCount > 2 && pHand.length === 0) {
                 loopCount++;
                 continue; 
            }
            
            found = true;
            break;
        }

        if (!found) {
            console.warn("æ‰¾ä¸åˆ°ä¸‹ä¸€ä½ç©å®¶");
        }

        update(ref(db, `ongame_room/${currentRoomId}`), {
            [`hands/${currentUserKey}`]: newHand,
            stack: stack,
            turnIndex: nextIdx,
            lastMove: { name: myName, count: played.length }
        });
        selectedLiarCards = [];
    };

    window.callLiar = async () => {
        if (isAnimating || processingAction) return; 
        
        const btnCall = document.getElementById('btn-liar-call');
        if(btnCall) btnCall.disabled = true;
        processingAction = true;

        const roomSnapshot = await get(ref(db, `ongame_room/${currentRoomId}`));
        const rData = roomSnapshot.val();

        if (!rData || !rData.stack || rData.stack.length === 0 || rData.gameState !== 'playing') {
            processingAction = false;
            if(btnCall) btnCall.disabled = false;
            return;
        }

        const stack = rData.stack;
        const lastEntry = stack[stack.length - 1];
        const target = rData.targetRank;
        
        if (rData.anytimeLiar && lastEntry.owner === currentUserKey) {
             processingAction = false;
             if(btnCall) btnCall.disabled = false;
             return alert("ä¸èƒ½æŠ“è‡ªå·±ï¼");
        }

        let isLiar = lastEntry.cards.some(c => c.rank !== target && c.rank !== 'Joker');
        
        const loserId = isLiar ? lastEntry.owner : currentUserKey;
        const loserUser = rData.users[loserId];
        const loserName = loserUser ? loserUser.name : "æœªçŸ¥ç©å®¶";

        const gun = rData.guns[loserId];
        const died = (gun.chamber === gun.bulletPos);
        const updates = {};
        
        updates[`guns/${loserId}/chamber`] = gun.chamber + 1;
        if(died) updates[`guns/${loserId}/isDead`] = true;
        
        updates['challengeResult'] = {
            cards: lastEntry.cards, isLiar, loser: loserId, loserName
        };
        updates['gameState'] = 'challenge';
        
        await update(ref(db, `ongame_room/${currentRoomId}`), updates);
    };

    function nextLiarRound(rData) {
        const players = rData.playerOrder;
        const alive = players.filter(p => !rData.guns[p].isDead);
        
        if (alive.length <= 1) {
            const winnerId = alive[0];
            const winnerUser = rData.users[winnerId];
            const winnerName = winnerUser ? winnerUser.name : "ç„¡äºº";
            update(ref(db, `ongame_room/${currentRoomId}`), {
                gameState: 'ended',
                winnerName: winnerName
            });
            return;
        }

        let suitCount = 6; 
        let jokerCount = 2;
        const playerCount = alive.length;

        if (playerCount >= 5) {
            suitCount = 8;
            jokerCount = 4;
            
            while ((suitCount * 3 + jokerCount) < (playerCount * 5)) {
                suitCount++;
                if (suitCount % 2 === 0) jokerCount++;
            }
        }

        const ranks = ['A', 'Q', 'K'];
        const baseSuits = ['â™ ', 'â™¥', 'â™¦', 'â™£'];
        let deck = [];
        
        ranks.forEach(r => {
            for (let i = 0; i < suitCount; i++) {
                deck.push({suit: baseSuits[i % 4], rank: r});
            }
        });
        
        for (let i = 0; i < jokerCount; i++) {
            deck.push({suit: '', rank: 'Joker'});
        }
        deck.sort(() => Math.random() - 0.5);
        
        const hands = {};
        alive.forEach(p => hands[p] = deck.splice(0, 5));

        let availableStarters = alive.filter(p => rData.users[p] && rData.users[p].status !== 'offline');
        if (availableStarters.length === 0) availableStarters = alive;

        const starter = availableStarters[Math.floor(Math.random()*availableStarters.length)];
        const startIdx = players.indexOf(starter);

        update(ref(db, `ongame_room/${currentRoomId}`), {
            gameState: 'playing', hands, deck, stack: [],
            targetRank: ranks[Math.floor(Math.random()*3)],
            turnIndex: startIdx, challengeResult: null,
            deckMeta: { suitCount, jokerCount } 
        });
    }
    
    // --- è¼”åŠ©å‡½å¼ ---
    function renderC4Board(data, rows, cols) {
        const boardDiv = document.getElementById('c4-board');
        boardDiv.style.gridTemplateColumns = `repeat(${cols}, var(--c4-cell-size))`;
        const size = cols > 10 ? '30px' : (cols > 7 ? '35px' : '45px');
        document.documentElement.style.setProperty('--c4-cell-size', size);
        boardDiv.innerHTML = "";
        data.board.forEach((val, i) => {
            const cell = document.createElement('div');
            cell.className = 'c4-cell';
            if(val > 0) cell.innerHTML = `<div class="piece p${val}"></div>`;
            cell.onclick = () => dropC4(i % cols, rows, cols);
            boardDiv.appendChild(cell);
        });
    }

    function renderTTTBoard(data, rows, cols) {
        const boardDiv = document.getElementById('ttt-board');
        boardDiv.style.gridTemplateColumns = `repeat(${cols}, 1fr)`;
        boardDiv.innerHTML = "";
        let indexToFade = -1;
        if (data.type === 'ttt-infinite' && data.moves) {
            const moves = data.moves;
            const currentSymbol = (data.turn % 2 === 0) ? 'X' : 'O';
            const myMoves = moves.filter(m => m.player === currentSymbol);
            if (myMoves.length >= 3) indexToFade = myMoves[0].index;
        }
        data.board.forEach((val, i) => {
            const cell = document.createElement('div');
            cell.className = 'ttt-cell';
            if (i === indexToFade) cell.classList.add('about-to-die');
            cell.innerText = val;
            cell.onclick = () => clickTTT(i);
            boardDiv.appendChild(cell);
        });
    }

    window.dropC4 = (col, rows, cols) => {
        if(roomDataCache.type !== 'c4') return;
        const board = [...roomDataCache.board];
        for (let r = rows - 1; r >= 0; r--) {
            const index = r * cols + col;
            if (board[index] === 0) {
                board[index] = (roomDataCache.turn % 2) + 1;
                updateMove(board);
                break;
            }
        }
    }
    
    window.clickTTT = (i) => {
        if(roomDataCache.type === 'c4' || roomDataCache.type === 'liar') return;
        if (roomDataCache.board[i] !== "") return;
        const isInfinite = (roomDataCache.type === 'ttt-infinite');
        const board = [...roomDataCache.board];
        const currentPlayer = roomDataCache.turn % 2 === 0 ? "X" : "O";
        let newMoves = isInfinite ? (roomDataCache.moves ? [...roomDataCache.moves] : []) : null;
        
        board[i] = currentPlayer;
        if (isInfinite) {
            newMoves.push({ index: i, player: currentPlayer });
            const myMoves = newMoves.filter(m => m.player === currentPlayer);
            if (myMoves.length > 3) {
                const moveToRemove = myMoves[0];
                board[moveToRemove.index] = "";
                const realIndex = newMoves.indexOf(moveToRemove);
                if (realIndex > -1) newMoves.splice(realIndex, 1);
            }
            updateMove(board, newMoves);
        } else {
            updateMove(board);
        }
    }

    function updateMove(newBoard, newMoves = null) {
        const history = roomDataCache.history || [];
        const isInfinite = (roomDataCache.type === 'ttt-infinite');
        if (isInfinite) {
            history.push({ board: newBoard, moves: newMoves });
            update(ref(db, `ongame_room/${currentRoomId}`), { board: newBoard, moves: newMoves, turn: roomDataCache.turn + 1, history: history });
        } else {
            history.push(newBoard);
            update(ref(db, `ongame_room/${currentRoomId}`), { board: newBoard, turn: roomDataCache.turn + 1, history: history });
        }
    }

    window.undoStep = () => {
        const history = roomDataCache.history || [];
        if (history.length <= 1) return alert("ä¸èƒ½å†é€€äº†ï¼");
        history.pop();
        const lastState = history[history.length - 1];
        const isInfinite = (roomDataCache.type === 'ttt-infinite');
        if (isInfinite) {
            update(ref(db, `ongame_room/${currentRoomId}`), { board: lastState.board||lastState, moves: lastState.moves||[], turn: roomDataCache.turn - 1, history: history });
        } else {
            update(ref(db, `ongame_room/${currentRoomId}`), { board: lastState, turn: roomDataCache.turn - 1, history: history });
        }
    };

    window.sendMessage = () => {
        const input = document.getElementById('chatInput');
        if (!input.value.trim()) return;
        push(ref(db, `ongame_room/${currentRoomId}/chat`), { user: myName, text: input.value, time: serverTimestamp() });
        input.value = "";
    };

    window.editName = () => {
        const newName = prompt("è«‹è¼¸å…¥æ‚¨çš„æ–°æš±ç¨±:", myName);
        if (newName && newName.trim() !== "") {
            myName = newName.trim();
            localStorage.setItem('playerName', myName);
            document.getElementById('myNameDisplay').innerText = myName;
            if (currentRoomId && currentUserKey) update(ref(db, `ongame_room/${currentRoomId}/users/${currentUserKey}`), { name: myName });
        }
    };

    function checkBoardWinner(data) {
        if(data.type === 'liar') return;

        const rows = data.rows || 3;
        const cols = data.cols || 3;
        const winTarget = data.winCondition || 3;
        const emptyVal = data.type === 'c4' ? 0 : "";
        const winner = checkWinGeneral(data.board, rows, cols, winTarget, emptyVal);
        const msgEl = document.getElementById('win-message');

        if (winner) {
            const userList = Object.values(data.users);
            let winnerName = (winner === 'X' || winner === 1) ? (userList[0]?.name||"P1") : (userList[1]?.name||"P2");
            msgEl.innerText = `ğŸ‰ æ­å–œ ${winnerName} ç²å‹ï¼ ğŸ‰`;
            msgEl.style.color = (winner === 'X' || winner === 1) ? '#f87171' : '#facc15';
            document.getElementById('win-overlay').style.display = 'flex';
        } else if (data.type !== 'ttt-infinite') {
            const isFull = data.board.every(c => c !== 0 && c !== "");
            if (isFull) {
                msgEl.innerText = `ğŸ¤ å¹³æ‰‹ï¼ ğŸ¤`;
                msgEl.style.color = "white";
                document.getElementById('win-overlay').style.display = 'flex';
            } else {
                document.getElementById('win-overlay').style.display = 'none';
            }
        }
    }

    function checkWinGeneral(board, rows, cols, target, emptyVal) {
        const getCell = (r, c) => (r < 0 || r >= rows || c < 0 || c >= cols) ? null : board[r * cols + c];
        const directions = [[0, 1], [1, 0], [1, 1], [1, -1]];
        for(let r = 0; r < rows; r++) {
            for(let c = 0; c < cols; c++) {
                const current = getCell(r, c);
                if (current === emptyVal || current === null) continue;
                for (let [dr, dc] of directions) {
                    let count = 1;
                    for (let k = 1; k < target; k++) {
                        if (getCell(r + dr * k, c + dc * k) === current) count++; else break;
                    }
                    if (count === target) return current;
                }
            }
        }
        return null;
    }

    window.resetGame = () => {
        if (!roomDataCache) return;
        if (roomDataCache.type === 'liar') {
            startLiarGame(); 
        } else {
            const rows = roomDataCache.rows || 3;
            const cols = roomDataCache.cols || 3;
            const initBoard = roomDataCache.type === 'c4' ? Array(rows*cols).fill(0) : Array(rows*cols).fill("");
            const history = roomDataCache.type === 'ttt-infinite' ? [{board:initBoard, moves:[]}] : [initBoard];
            update(ref(db, `ongame_room/${currentRoomId}`), { 
                board: initBoard, moves: [], turn: 0, history: history 
            });
        }
        closeWinOverlay();
    };

    window.closeWinOverlay = () => document.getElementById('win-overlay').style.display = 'none';
    window.showSection = (id) => {
        document.querySelectorAll('.container').forEach(c => c.classList.add('hidden'));
        document.getElementById(id).classList.remove('hidden');
    };
    
    window.leaveRoom = () => {
        if (currentRoomId && currentUserKey) {
            if (isLiarGame) {
                update(ref(db, `ongame_room/${currentRoomId}/users/${currentUserKey}`), { status: 'offline' })
                    .then(() => location.reload());
            } else if (roomDataCache && roomDataCache.type === 'uno') {
                update(ref(db, `ongame_room/${currentRoomId}/users/${currentUserKey}`), { online: false })
                    .then(() => location.reload());
            } else {
                location.reload();
            }
        } else {
            location.reload();
        }
    };
    
    window.deleteRoom = (id) => { if(confirm("ç¢ºå®šåˆªé™¤ï¼Ÿ")) remove(ref(db, 'ongame_room/' + id)); };
    
    const p1Picker = document.getElementById('p1ColorPicker');
    const p2Picker = document.getElementById('p2ColorPicker');
    const updateColors = () => {
        document.documentElement.style.setProperty('--p1-color', p1Picker.value);
        document.documentElement.style.setProperty('--p2-color', p2Picker.value);
    };
    p1Picker.addEventListener('input', updateColors);
    p2Picker.addEventListener('input', updateColors);
    p1Picker.addEventListener('change', () => {
        if(currentRoomId && roomDataCache.type === 'c4') update(ref(db, `ongame_room/${currentRoomId}`), { p1Color: p1Picker.value });
    });
    p2Picker.addEventListener('change', () => {
        if(currentRoomId && roomDataCache.type === 'c4') update(ref(db, `ongame_room/${currentRoomId}`), { p2Color: p2Picker.value });
    });

</script>
</body>
</html>
